C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\app.py:
"""
Calendar Integration Flask App
This module creates and exports the Flask app instance for the router to import.
"""

from calendar_integration import create_app

# Create the Flask app instance
app = create_app()

if __name__ == "__main__":
    # For local development
    import os
    host = os.getenv('HOST', '0.0.0.0')
    port = int(os.getenv('PORT', 5000))
    debug = os.getenv('DEBUG', 'True') == 'True'
    
    print(f"Starting calendar integration service on {host}:{port}")
    app.run(host=host, port=port, debug=debug)
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\app.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\google_tokens.json:
{} 
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\google_tokens.json ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\main.py:
"""
ASGI entry-point for the calendar sub-site.

* Wraps a Flask app in WsgiToAsgi so the parent router
  can mount it alongside /desktop and /mobile.
* Starts background scheduler on import.
"""

from __future__ import annotations

from flask import Flask
from werkzeug.middleware.proxy_fix import ProxyFix
from asgiref.wsgi import WsgiToAsgi

from calendar_integration.api import calendar_api
from calendar_integration.tasks.scheduler import start_scheduler
from calendar_integration.utils.logger import get_logger

log = get_logger("calendar_integration.main")


def _create_flask() -> Flask:
    app = Flask("calendar_integration")
    app.wsgi_app = ProxyFix(app.wsgi_app, x_for=1, x_proto=1)  # type: ignore[arg-type]
    app.register_blueprint(calendar_api, url_prefix="/calendar")
    return app


# Flask WSGI app
_flask_app = _create_flask()

# Kick off background jobs
start_scheduler()
log.info("Scheduler started")

# Exported ASGI app for router  
asgi_app = WsgiToAsgi(_flask_app)

# For direct execution
if __name__ == "__main__":
    import os
    host = os.getenv('HOST', '0.0.0.0')
    port = int(os.getenv('PORT', 5000))
    debug = os.getenv('DEBUG', 'True') == 'True'
    
    log.info(f"Starting calendar integration service on {host}:{port}")
    log.info(f"Debug mode: {debug}")
    
    try:
        _flask_app.run(host=host, port=port, debug=debug)
    except KeyboardInterrupt:
        log.info("Shutting down calendar integration service")
    except Exception as e:
        log.error(f"Error starting application: {e}") 
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\main.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\models.py:
from dataclasses import dataclass
from typing import Optional
from datetime import datetime

@dataclass
class CalendarEvent:
    title: str
    description: Optional[str] = None
    start_time: Optional[datetime] = None
    end_time: Optional[datetime] = None
    location: Optional[str] = None
    flowchart: Optional[str] = None
    event_id: Optional[str] = None
    user_id: Optional[str] = None
    type: Optional[str] = None

    def to_dict(self):
        return {
            "title": self.title,
            "description": self.description,
            "start_time": self.start_time.isoformat() if self.start_time else None,
            "end_time": self.end_time.isoformat() if self.end_time else None,
            "location": self.location,
            "flowchart": self.flowchart,
            "event_id": self.event_id,
            "user_id": self.user_id,
            "type": self.type
        } 
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\models.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\README.md:
# Calendar Integration Service

A Flask-based calendar integration service that connects to CalDAV servers and provides AI-powered event generation capabilities.

## Features

- **CalDAV Integration**: Connect to any CalDAV-compatible calendar server (Nextcloud, Google Calendar, etc.)
- **AI Event Generation**: Generate personalized calendar events using OpenAI GPT-4
- **RESTful API**: Full CRUD operations for calendar events
- **Scheduled Events**: Automated weekly and daily event creation
- **Authentication**: Basic user authentication system
- **Comprehensive Logging**: Structured logging for monitoring and debugging
- **Input Validation**: Robust validation for all API inputs

## Prerequisites

- Python 3.8+
- CalDAV server (Nextcloud, Google Calendar, etc.)
- OpenAI API key (for AI event generation)

## Installation

1. **Clone the repository**:
   ```bash
   git clone <repository-url>
   cd calendar_integration
   ```

2. **Install dependencies**:
   ```bash
   pip install -r requirements.txt
   ```

3. **Set up environment variables**:
   Create a `.env` file in the root directory:
   ```env
   # CalDAV Configuration
   CALDAV_SERVER_URL=https://your-caldav-server.com
   CALDAV_USERNAME=your_username
   CALDAV_PASSWORD=your_password
   CALENDAR_NAME=pitext_calendar
   
   # OpenAI Configuration
   OPENAI_API_KEY=your_openai_api_key
   
   # Application Configuration
   HOST=0.0.0.0
   PORT=5000
   DEBUG=True
   ```

## Usage

### Starting the Service

```bash
python main.py
```

The service will start on the configured host and port (default: `http://localhost:5000`).

### API Endpoints

#### Health Check
```http
GET /calendar/
```

#### Get All Events
```http
GET /calendar/events?user_id=user1
Headers: X-API-Key: password123
```

#### Get Specific Event
```http
GET /calendar/events/{event_id}?user_id=user1
Headers: X-API-Key: password123
```

#### Create Event
```http
POST /calendar/events
Headers: X-API-Key: password123
Content-Type: application/json

{
  "title": "Team Meeting",
  "description": "Weekly team sync",
  "start_time": "2024-01-15T10:00:00",
  "end_time": "2024-01-15T11:00:00",
  "location": "Conference Room A"
}
```

#### Update Event
```http
PUT /calendar/events/{event_id}?user_id=user1
Headers: X-API-Key: password123
Content-Type: application/json

{
  "title": "Updated Team Meeting",
  "description": "Updated description"
}
```

#### Delete Event
```http
DELETE /calendar/events/{event_id}?user_id=user1
Headers: X-API-Key: password123
```

#### Generate AI Events
```http
POST /calendar/generate-events
Headers: X-API-Key: password123
Content-Type: application/json

{
  "interests": ["technology", "programming", "AI"]
}
```

### Authentication

The service uses a simple API key authentication system:

- **user_id**: Passed as a query parameter
- **X-API-Key**: Passed as a header (acts as password)

Pre-configured users:
- `user1` / `password123` (interests: technology, programming)
- `user2` / `password456` (interests: sports, fitness)

### Scheduled Events

The service includes a scheduler that can automatically create events:

```python
from calendar_integration.tasks.scheduled_event_creator import scheduler

# Schedule weekly events
scheduler.schedule_weekly_events("user1", ["technology", "programming"], "monday")

# Schedule daily reminders
scheduler.schedule_daily_reminders("user1", "work")

# Start the scheduler
scheduler.start_scheduler()
```

## Configuration

### CalDAV Server Setup

1. **Nextcloud**: 
   - URL: `https://your-nextcloud.com/remote.php/dav/calendars/username/`
   - Username: Your Nextcloud username
   - Password: Your Nextcloud password

2. **Google Calendar**:
   - URL: `https://calendar.google.com/dav/`
   - Username: Your Google email
   - Password: App-specific password (not your regular password)

### Environment Variables

| Variable | Description | Required | Default |
|----------|-------------|----------|---------|
| `CALDAV_SERVER_URL` | CalDAV server URL | Yes | - |
| `CALDAV_USERNAME` | CalDAV username | Yes | - |
| `CALDAV_PASSWORD` | CalDAV password | Yes | - |
| `CALENDAR_NAME` | Calendar name to use | No | `pitext_calendar` |
| `OPENAI_API_KEY` | OpenAI API key | No | - |
| `HOST` | Application host | No | `0.0.0.0` |
| `PORT` | Application port | No | `5000` |
| `DEBUG` | Debug mode | No | `True` |

## Error Handling

The service includes comprehensive error handling:

- **Validation Errors**: Input validation with detailed error messages
- **Authentication Errors**: Proper HTTP 401 responses
- **OpenAI API Errors**: Rate limiting, authentication, and quota handling
- **CalDAV Errors**: Connection and calendar operation error handling
- **Logging**: All errors are logged with context

## Logging

Logs are written to both console and `calendar_integration.log` file. Log levels:
- `INFO`: General application flow
- `WARNING`: Non-critical issues
- `ERROR`: Errors that need attention

## Development

### Project Structure

```
calendar_integration/
├── api/                    # API routes and models
│   ├── calendar_routes.py  # Main API endpoints
│   ├── config.py          # Configuration management
│   ├── models.py          # Data models
│   └── auth.py            # Authentication
├── services/              # Business logic
│   ├── calendar_client.py # CalDAV client
│   └── event_generator.py # AI event generation
├── tasks/                 # Background tasks
│   └── scheduled_event_creator.py
├── utils/                 # Utilities
│   ├── logger.py          # Logging configuration
│   ├── validators.py      # Input validation
│   └── helpers.py         # Helper functions
├── main.py               # Application entry point
└── requirements.txt      # Dependencies
```

### Running Tests

```bash
# Run all tests
python -m pytest

# Run with coverage
python -m pytest --cov=calendar_integration
```

## Troubleshooting

### Common Issues

1. **CalDAV Connection Failed**:
   - Verify server URL, username, and password
   - Check if CalDAV is enabled on your server
   - Ensure network connectivity

2. **OpenAI API Errors**:
   - Verify API key is correct
   - Check API quota and rate limits
   - Ensure internet connectivity

3. **Authentication Failures**:
   - Verify user_id and API key combination
   - Check if user exists in the system

4. **Event Creation Failures**:
   - Verify event data format
   - Check start_time is before end_time
   - Ensure all required fields are provided

### Logs

Check the `calendar_integration.log` file for detailed error information and debugging.

## Security Considerations

- **Production Deployment**: Use HTTPS and proper authentication
- **API Keys**: Store API keys securely (use environment variables)
- **User Management**: Implement proper user management system
- **Input Validation**: All inputs are validated to prevent injection attacks
- **Logging**: Sensitive data is not logged

## Contributing

1. Fork the repository
2. Create a feature branch
3. Make your changes
4. Add tests for new functionality
5. Submit a pull request

## License

This project is licensed under the MIT License. 
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\README.md ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\requirements.txt:
Flask>=3.0.0
requests>=2.32.3
python-dotenv>=1.0.1
openai>=1.32.0
asgiref>=3.7.0
structlog>=23.1.0
schedule>=1.2.0
Flask-WTF>=1.2.1
# Calendar Integration Dependencies 
google-api-python-client
google-auth
google-auth-oauthlib
google-auth-httplib2 
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\requirements.txt ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\test_modular_js.py:
#!/usr/bin/env python3
"""
Test script for the new modular JavaScript structure.
"""

import sys
import os

# Add the parent directory to the path so we can import calendar_integration
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

def test_js_files_exist():
    """Test that all new JavaScript files exist."""
    js_files = [
        'static/js/core.js',
        'static/js/api.js', 
        'static/js/ui.js',
        'static/js/mermaid.js'
    ]
    
    missing_files = []
    for file_path in js_files:
        if not os.path.exists(file_path):
            missing_files.append(file_path)
    
    if missing_files:
        print(f"✗ Missing JavaScript files: {missing_files}")
        return False
    else:
        print("✓ All JavaScript files exist")
        return True

def test_js_file_sizes():
    """Test that JavaScript files are under 300 lines."""
    js_files = [
        ('static/js/core.js', 'core.js'),
        ('static/js/api.js', 'api.js'),
        ('static/js/ui.js', 'ui.js'),
        ('static/js/mermaid.js', 'mermaid.js')
    ]
    
    oversized_files = []
    for file_path, name in js_files:
        try:
            with open(file_path, 'r') as f:
                lines = f.readlines()
                if len(lines) > 300:
                    oversized_files.append(f"{name} ({len(lines)} lines)")
        except Exception as e:
            print(f"✗ Error reading {name}: {e}")
            return False
    
    if oversized_files:
        print(f"✗ Files over 300 lines: {oversized_files}")
        return False
    else:
        print("✓ All JavaScript files are under 300 lines")
        return True

def test_js_syntax():
    """Test that JavaScript files have basic syntax structure."""
    js_files = [
        ('static/js/core.js', 'core.js'),
        ('static/js/api.js', 'api.js'),
        ('static/js/ui.js', 'ui.js'),
        ('static/js/mermaid.js', 'mermaid.js')
    ]
    
    syntax_errors = []
    for file_path, name in js_files:
        try:
            with open(file_path, 'r') as f:
                content = f.read()
                
                # Basic syntax checks
                if 'export' in content and 'import' in content:
                    print(f"✓ {name} uses ES6 modules")
                elif 'export' in content or 'import' in content:
                    print(f"⚠ {name} has partial ES6 module usage")
                else:
                    print(f"⚠ {name} doesn't use ES6 modules")
                    
                # Check for basic structure
                if 'function' in content or '=>' in content:
                    print(f"✓ {name} has function definitions")
                else:
                    syntax_errors.append(f"{name} (no functions found)")
                    
        except Exception as e:
            print(f"✗ Error reading {name}: {e}")
            return False
    
    if syntax_errors:
        print(f"✗ Syntax issues: {syntax_errors}")
        return False
    else:
        print("✓ All JavaScript files have basic syntax structure")
        return True

def test_html_template():
    """Test that HTML template includes the new modular JavaScript."""
    template_path = 'templates/calendar.html'
    
    try:
        with open(template_path, 'r') as f:
            content = f.read()
            
        # Check for ES6 module script tag
        if 'type="module"' in content:
            print("✓ HTML template uses ES6 modules")
        else:
            print("✗ HTML template doesn't use ES6 modules")
            return False
            
        # Check for modal dialog
        if '<dialog id="event-modal">' in content:
            print("✓ HTML template includes event modal")
        else:
            print("✗ HTML template missing event modal")
            return False
            
        # Check for user-id meta tag
        if 'name="user-id"' in content:
            print("✓ HTML template includes user-id meta tag")
        else:
            print("✗ HTML template missing user-id meta tag")
            return False
            
        return True
        
    except Exception as e:
        print(f"✗ Error reading HTML template: {e}")
        return False

def main():
    """Run all tests."""
    print("Testing new modular JavaScript structure...")
    print("-" * 50)
    
    tests = [
        test_js_files_exist,
        test_js_file_sizes,
        test_js_syntax,
        test_html_template,
    ]
    
    passed = 0
    total = len(tests)
    
    for test in tests:
        if test():
            passed += 1
        print()
    
    print("-" * 50)
    print(f"Tests passed: {passed}/{total}")
    
    if passed == total:
        print("🎉 All tests passed!")
        print("\nNew modular JavaScript structure is ready:")
        print("• core.js - FullCalendar bootstrap and event bridging")
        print("• api.js - Minimal fetch wrappers with CSRF support") 
        print("• ui.js - Modal handling and pub-sub functionality")
        print("• mermaid.js - SVG rendering and click event wiring")
        return 0
    else:
        print("❌ Some tests failed!")
        return 1

if __name__ == "__main__":
    sys.exit(main()) 
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\test_modular_js.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\test_tasks.py:
#!/usr/bin/env python3
"""
Simple test script for the new tasks structure.
"""

import sys
import os

# Add the parent directory to the path so we can import calendar_integration
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

def test_tasks_import():
    """Test that all task modules can be imported."""
    try:
        from calendar_integration.tasks import start_scheduler, create_weekly_events, create_daily_reminders
        print("✓ Successfully imported task functions")
        return True
    except ImportError as e:
        print(f"✗ Failed to import task functions: {e}")
        return False

def test_scheduler_creation():
    """Test that scheduler can be created without starting thread."""
    try:
        from calendar_integration.tasks import start_scheduler
        # Test without starting thread
        start_scheduler(start_thread=False)
        print("✓ Scheduler created successfully")
        return True
    except Exception as e:
        print(f"✗ Failed to create scheduler: {e}")
        return False

def test_weekly_task():
    """Test that weekly task function exists and is callable."""
    try:
        from calendar_integration.tasks import create_weekly_events
        # Just test that it's callable, don't actually run it
        assert callable(create_weekly_events)
        print("✓ Weekly task function is callable")
        return True
    except Exception as e:
        print(f"✗ Failed to test weekly task: {e}")
        return False

def test_daily_task():
    """Test that daily task function exists and is callable."""
    try:
        from calendar_integration.tasks import create_daily_reminders
        # Just test that it's callable, don't actually run it
        assert callable(create_daily_reminders)
        print("✓ Daily task function is callable")
        return True
    except Exception as e:
        print(f"✗ Failed to test daily task: {e}")
        return False

def main():
    """Run all tests."""
    print("Testing new tasks structure...")
    print("-" * 40)
    
    tests = [
        test_tasks_import,
        test_scheduler_creation,
        test_weekly_task,
        test_daily_task,
    ]
    
    passed = 0
    total = len(tests)
    
    for test in tests:
        if test():
            passed += 1
        print()
    
    print("-" * 40)
    print(f"Tests passed: {passed}/{total}")
    
    if passed == total:
        print("🎉 All tests passed!")
        return 0
    else:
        print("❌ Some tests failed!")
        return 1

if __name__ == "__main__":
    sys.exit(main()) 
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\test_tasks.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\test_utils.py:
#!/usr/bin/env python3
"""
Simple test script for the new utils structure.
"""

import sys
import os

# Add the parent directory to the path so we can import calendar_integration
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

def test_logger():
    """Test that logger can be created and used."""
    try:
        from calendar_integration.utils.logger import get_logger
        logger = get_logger("test_logger")
        logger.info("Test log message")
        print("✓ Logger created and used successfully")
        return True
    except Exception as e:
        print(f"✗ Failed to test logger: {e}")
        return False

def test_validators():
    """Test that validators work correctly."""
    try:
        from calendar_integration.utils.validators import is_email, require_keys, validate_event_data
        
        # Test email validation
        assert is_email("test@example.com") == True
        assert is_email("invalid-email") == False
        
        # Test require_keys
        test_dict = {"a": 1, "b": 2}
        require_keys(test_dict, ["a", "b"])  # Should not raise
        
        # Test validate_event_data
        valid_event = {
            "title": "Test Event",
            "start_time": "2024-01-01T10:00:00",
            "end_time": "2024-01-01T11:00:00"
        }
        validate_event_data(valid_event)  # Should not raise
        
        print("✓ Validators work correctly")
        return True
    except Exception as e:
        print(f"✗ Failed to test validators: {e}")
        return False

def test_datetime():
    """Test that datetime helpers work correctly."""
    try:
        from calendar_integration.utils.datetime import parse_datetime, parse_iso, now_utc
        
        # Test parse_datetime
        dt = parse_datetime("2024-01-01T10:00:00")
        assert dt is not None
        
        # Test parse_iso
        dt2 = parse_iso("2024-01-01T10:00:00")
        assert dt2 is not None
        
        # Test now_utc
        utc_now = now_utc()
        assert utc_now is not None
        
        print("✓ Datetime helpers work correctly")
        return True
    except Exception as e:
        print(f"✗ Failed to test datetime helpers: {e}")
        return False

def test_utils_import():
    """Test that utils package can be imported."""
    try:
        from calendar_integration.utils import (
            get_logger, 
            parse_datetime, 
            validate_event_data,
            is_email,
            require_keys
        )
        print("✓ Utils package imports successfully")
        return True
    except ImportError as e:
        print(f"✗ Failed to import utils package: {e}")
        return False

def main():
    """Run all tests."""
    print("Testing new utils structure...")
    print("-" * 40)
    
    tests = [
        test_logger,
        test_validators,
        test_datetime,
        test_utils_import,
    ]
    
    passed = 0
    total = len(tests)
    
    for test in tests:
        if test():
            passed += 1
        print()
    
    print("-" * 40)
    print(f"Tests passed: {passed}/{total}")
    
    if passed == total:
        print("🎉 All tests passed!")
        return 0
    else:
        print("❌ Some tests failed!")
        return 1

if __name__ == "__main__":
    sys.exit(main()) 
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\test_utils.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\__init__.py:
# calendar_integration/__init__.py
import os
from flask import Flask, request
from flask_wtf.csrf import CSRFProtect
import traceback

csrf = CSRFProtect()  # Make CSRFProtect instance importable

def create_app():
    try:
        app = Flask(__name__, 
                    static_folder='static',
                    template_folder='templates')
        
        # Configure secret key for CSRF protection
        app.config['SECRET_KEY'] = os.getenv('CALENDAR_SECRET_KEY', 'your-secret-key-here')
        
        # Disable CSRF protection globally - we'll implement our own where needed
        app.config['WTF_CSRF_ENABLED'] = False
        
        # Initialize CSRF protection (disabled)
        csrf.init_app(app)

        # Add CORS headers
        @app.after_request
        def after_request(response):
            response.headers.add('Access-Control-Allow-Origin', '*')
            response.headers.add('Access-Control-Allow-Headers', 'Content-Type,Authorization,X-CSRFToken')
            response.headers.add('Access-Control-Allow-Methods', 'GET,PUT,POST,DELETE,OPTIONS')
            return response

        # Import and register blueprints - moved inside function to avoid circular imports
        try:
            from calendar_integration.api import calendar_api
            app.register_blueprint(calendar_api, url_prefix='')
            
            print("Calendar API blueprint registered successfully!")
        except Exception as e:
            print(f"Warning: Could not import calendar_api: {e}")
            traceback.print_exc()
            # Create a simple fallback route
            @app.route('/calendar/health')
            def health_fallback_api():
                return {"status": "degraded", "message": "Calendar API not available"}, 200

        return app
    except Exception as e:
        print(f"Error creating calendar app: {e}")
        traceback.print_exc()
        # Return a minimal app that at least responds
        app = Flask(__name__)
        @app.route('/calendar/health')
        def health_fallback_minimal():
            return {"status": "error", "message": "Calendar service unavailable"}, 500
        return app
# Calendar Integration Module 
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\__init__.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\api\auth.py:
# api/auth.py
import os
from functools import wraps
from flask import request, jsonify
from calendar_integration.utils.logger import get_logger
from typing import Optional

logger = get_logger(__name__)

# Simple in-memory user store (in production, use a proper database)
USERS = {
    "user1": {"password": "password123", "interests": ["technology", "programming"]},
    "user2": {"password": "password456", "interests": ["sports", "fitness"]},
}

def validate_user(user_id: Optional[str], password: Optional[str] = None) -> bool:
    """Validate user credentials."""
    if not user_id or user_id not in USERS:
        return False
    
    if password and USERS[user_id]["password"] != password:
        return False
    
    return True

def get_user_interests(user_id: str) -> list:
    """Get user interests."""
    if user_id in USERS:
        return USERS[user_id].get("interests", [])
    return []

def require_auth(f):
    """Decorator to require authentication."""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        user_id = request.args.get('user_id')
        password = request.headers.get('X-API-Key')  # Using API key as password
        
        if not validate_user(user_id, password):
            logger.warning(f"Authentication failed for user: {user_id}")
            return jsonify({"error": "Authentication required", "status": "error"}), 401
        
        logger.info(f"Authentication successful for user: {user_id}")
        return f(*args, **kwargs)
    
    return decorated_function

def require_user_id(f):
    """Decorator to require user_id parameter."""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        user_id = request.args.get('user_id')
        
        if not user_id or not user_id.strip():
            logger.warning("Missing or empty user_id parameter")
            return jsonify({"error": "user_id is required", "status": "error"}), 400
        
        return f(*args, **kwargs)
    
    return decorated_function 
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\api\auth.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\api\config.py:
# api/config.py
import os

class Config:
    # Local database configuration
    CALENDAR_EVENTS_FILE = os.getenv('CALENDAR_EVENTS_FILE', 'calendar_events.json')
    CALENDAR_NAME = os.getenv('CALENDAR_NAME', 'pitext_calendar')

    @staticmethod
    def validate():
        # No validation needed for local database
        pass
# Calendar API Configuration 
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\api\config.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\api\events.py:
"""
Calendar event CRUD endpoints.

Public routes
-------------
GET    /calendar/events
POST   /calendar/events
PUT    /calendar/events/<event_id>
DELETE /calendar/events/<event_id>
POST   /calendar/generate-events
"""

from __future__ import annotations

from typing import Any

from flask import Blueprint, request, render_template, send_from_directory
import os
from datetime import datetime

from calendar_integration.services.calendar_client import CalendarClient
from calendar_integration.services.event_generator import EventGenerator
from calendar_integration.utils.logger import get_logger
from calendar_integration.api._helpers import csrf_protect, ok, err, parse_json, require_args

events_bp = Blueprint("events", __name__)
logger = get_logger(__name__)

client = CalendarClient()  # imported once, thread-safe
event_generator = EventGenerator()

# ---------------------------------------------------------------------
# Main calendar page
# ---------------------------------------------------------------------
@events_bp.get("/")
def index():
    """Main calendar page."""
    logger.info("Calendar index page requested")
    return render_template('calendar.html')

# ---------------------------------------------------------------------
# Favicon
# ---------------------------------------------------------------------
@events_bp.get("/favicon.ico")
def favicon():
    """Serve favicon."""
    current_dir = os.path.dirname(os.path.abspath(__file__))
    static_folder = os.path.join(os.path.dirname(current_dir), 'static')
    return send_from_directory(static_folder, 'favicon.ico')

# ---------------------------------------------------------------------
# Health check
# ---------------------------------------------------------------------
@events_bp.get("/health")
def health_check():
    """Health check endpoint."""
    logger.info("Health check requested")
    return ok({
        "calendar_client_initialized": True,  # Always initialized with new storage
        "event_generator_initialized": event_generator.initialized,
        "timestamp": datetime.utcnow().isoformat()
    })

# ---------------------------------------------------------------------
# CSRF token
# ---------------------------------------------------------------------
@events_bp.get("/csrf-token")
def get_csrf_token():
    """Get CSRF token for calendar operations."""
    from flask_wtf.csrf import generate_csrf
    try:
        csrf_token = generate_csrf()
        logger.info("CSRF token generated successfully")
        return ok({"csrf_token": csrf_token})
    except Exception as e:
        logger.error(f"Failed to generate CSRF token: {str(e)}")
        return err("Failed to generate CSRF token", 500)

# ---------------------------------------------------------------------
# Set session user
# ---------------------------------------------------------------------
@events_bp.post("/set-session-user")
def set_session_user():
    """Set user_id in session for OAuth flow."""
    from flask import session
    data = parse_json(request)
    user_id = data.get('user_id')
    if user_id:
        session['user_id'] = user_id
        session.modified = True
        logger.info(f"Set session user_id: {user_id}")
        return ok({"status": "success"})
    return err("No user_id provided", 400)

# ---------------------------------------------------------------------
# List events
# ---------------------------------------------------------------------
@events_bp.get("/events")
@require_args("user_id")
def list_events():
    """Get all events for a user."""
    user_id = request.args.get("user_id")
    logger.info(f"Fetching events for user: {user_id}")
    
    # Check for Google token
    token_path = os.path.join(os.path.dirname(__file__), '..', 'google_tokens.json')
    try:
        with open(token_path, 'r') as f:
            import json
            token_data = json.load(f)
            logger.info(f"Available tokens for users: {list(token_data.keys())}")
    except Exception as e:
        logger.warning(f"Could not read token file: {e}")
        token_data = {}
    
    user_token = token_data.get(user_id)
    
    if user_token:
        logger.info(f"Found Google token for user {user_id}, using GoogleCalendarClient")
        # Use GoogleCalendarClient
        try:
            from google.oauth2.credentials import Credentials
            from calendar_integration.services.google_calendar_client import GoogleCalendarClient
            
            creds = Credentials(
                token=user_token.get('access_token'),
                refresh_token=user_token.get('refresh_token'),
                token_uri='https://oauth2.googleapis.com/token',
                client_id=os.getenv('GOOGLE_CLIENT_ID'),
                client_secret=os.getenv('GOOGLE_CLIENT_SECRET'),
                scopes=['https://www.googleapis.com/auth/calendar.readonly']
            )
            google_client = GoogleCalendarClient(creds)
            events = google_client.fetch_events()
            logger.info(f"Fetched {len(events)} events from Google Calendar")
            
            # Format Google events to match your schema
            formatted_events = []
            for event in events:
                formatted_event = {
                    'event_id': event.get('id'),
                    'title': event.get('summary', 'Untitled'),
                    'description': event.get('description', ''),
                    'location': event.get('location', ''),
                    'start_time': event.get('start', {}).get('dateTime', event.get('start', {}).get('date')),
                    'end_time': event.get('end', {}).get('dateTime', event.get('end', {}).get('date')),
                    'all_day': 'date' in event.get('start', {}),
                    'source': 'google'
                }
                formatted_events.append(formatted_event)
            
            return ok(formatted_events)
        except Exception as e:
            logger.error(f"Error fetching Google Calendar events: {e}")
            # Fall back to local calendar
    else:
        logger.info(f"No Google token found for user {user_id}, using local calendar")
    
    # Use local CalendarClient
    events = client.fetch_events(user_id) if user_id else []
    if isinstance(events, dict) and "error" in events:
        logger.error(f"Error fetching events: {events['error']}")
        return err(events["error"], 500)
    if not isinstance(events, list):
        logger.error("Invalid events data format")
        return err("Invalid events data format", 500)
    logger.info(f"Successfully fetched {len(events)} events for user: {user_id}")
    return ok(events)

# ---------------------------------------------------------------------
# Get specific event
# ---------------------------------------------------------------------
@events_bp.get("/events/<string:event_id>")
@require_args("user_id")
def get_event(event_id: str):
    """Get a specific event by ID."""
    user_id = request.args.get("user_id")
    logger.info(f"Fetching event {event_id} for user: {user_id}")
    
    try:
        events = client.fetch_events(user_id)
        
        if isinstance(events, dict) and "error" in events:
            logger.error(f"Error fetching events: {events['error']}")
            return err(events["error"], 500)
        
        if not isinstance(events, list):
            logger.error("Invalid events data format")
            return err("Invalid events data format", 500)
        
        # Find the specific event
        for event in events:
            if isinstance(event, dict):
                event_id_from_data = event.get('id') or event.get('event_id')
                if str(event_id_from_data) == str(event_id):
                    logger.info(f"Successfully found event {event_id}")
                    return ok(event)
        
        logger.warning(f"Event {event_id} not found for user: {user_id}")
        return err("Event not found", 404)
        
    except Exception as e:
        logger.error(f"Unexpected error in get_event: {str(e)}")
        return err("Internal server error", 500)

# ---------------------------------------------------------------------
# Create an event
# ---------------------------------------------------------------------
@events_bp.post("/events")
def create_event():
    """Create a new event."""
    logger.info("=== CREATE EVENT REQUEST START ===")
    
    # Validate CSRF token for POST requests (make it optional for now)
    try:
        from flask_wtf.csrf import validate_csrf
        csrf_token = request.headers.get('X-CSRFToken')
        if csrf_token:
            validate_csrf(csrf_token)
            logger.info("CSRF token validation passed")
        else:
            logger.warning("No CSRF token provided in request")
    except Exception as e:
        logger.warning(f"CSRF token validation failed: {e}")
        # Don't return error, just log the warning
    
    payload = parse_json(request)
    logger.info(f"Request body: {payload}")
    
    # Validate user_id in request body
    user_id = payload.get('user_id')
    logger.info(f"User ID from request: {user_id}")
    
    if not user_id or not user_id.strip():
        logger.warning("Invalid or missing user_id in create_event request body")
        return err("user_id is required in request body and must not be empty", 400)
    
    logger.info(f"Creating new event: {payload.get('title', 'Untitled')} for user: {user_id}")
    
    try:
        # Validate event data
        logger.info("Validating event data...")
        from calendar_integration.utils.validators import validate_event_data
        validate_event_data(payload)
        logger.info("Event data validation passed")
        
        # Parse datetime strings if needed
        from calendar_integration.utils.datetime import parse_datetime
        if isinstance(payload.get('start_time'), str):
            payload['start_time'] = parse_datetime(payload['start_time'])
            logger.info(f"Parsed start_time: {payload['start_time']}")
        if isinstance(payload.get('end_time'), str):
            payload['end_time'] = parse_datetime(payload['end_time'])
            logger.info(f"Parsed end_time: {payload['end_time']}")
        
        logger.info("Calling calendar_client.create_event...")
        event = client.create_event(payload)
        logger.info(f"Calendar client response: {event}")
        
        if isinstance(event, dict) and "error" in event:
            logger.error(f"Error creating event: {event['error']}")
            return err(event["error"], 400)
        
        logger.info(f"Successfully created event: {event.get('event_id')}")
        logger.info("=== CREATE EVENT REQUEST END ===")
        return ok(event, 201)
        
    except ValueError as e:
        logger.error(f"Validation error creating event: {str(e)}")
        return err(f"Validation error: {str(e)}", 400)
    except Exception as e:
        logger.error(f"Unexpected error in create_event: {str(e)}")
        logger.error(f"Exception type: {type(e)}")
        import traceback
        logger.error(f"Traceback: {traceback.format_exc()}")
        return err("Internal server error", 500)

# ---------------------------------------------------------------------
# Update event
# ---------------------------------------------------------------------
@events_bp.put("/events/<string:event_id>")
def update_event(event_id: str):
    """Update an existing event."""
    # Validate CSRF token for PUT requests (make it optional for now)
    try:
        from flask_wtf.csrf import validate_csrf
        csrf_token = request.headers.get('X-CSRFToken')
        if csrf_token:
            validate_csrf(csrf_token)
        else:
            logger.warning("No CSRF token provided in request")
    except Exception as e:
        logger.warning(f"CSRF token validation failed: {e}")
        # Don't return error, just log the warning
    
    payload = parse_json(request)
    user_id = request.args.get('user_id')
    
    if not user_id or not user_id.strip():
        logger.warning("Invalid or missing user_id in update_event request")
        return err("user_id is required and must not be empty", 400)
    
    if not event_id:
        logger.warning("Missing event_id in update_event request")
        return err("event_id is required", 400)
    
    logger.info(f"Updating event {event_id} for user: {user_id}")
    
    try:
        # Validate event data
        from calendar_integration.utils.validators import validate_event_data
        validate_event_data(payload)
        
        # Parse datetime strings if needed
        from calendar_integration.utils.datetime import parse_datetime
        if isinstance(payload.get('start_time'), str):
            payload['start_time'] = parse_datetime(payload['start_time'])
        if isinstance(payload.get('end_time'), str):
            payload['end_time'] = parse_datetime(payload['end_time'])
        
        updated_event = client.update_event(event_id, payload)
        
        if isinstance(updated_event, dict) and "error" in updated_event:
            logger.error(f"Error updating event: {updated_event['error']}")
            return err(updated_event["error"], 404)
        
        logger.info(f"Successfully updated event: {event_id}")
        return ok(updated_event)
        
    except ValueError as e:
        logger.error(f"Validation error updating event: {str(e)}")
        return err(f"Validation error: {str(e)}", 400)
    except Exception as e:
        logger.error(f"Unexpected error in update_event: {str(e)}")
        return err("Internal server error", 500)

# ---------------------------------------------------------------------
# Delete event
# ---------------------------------------------------------------------
@events_bp.delete("/events/<string:event_id>")
def delete_event(event_id: str):
    """Delete an event."""
    # Validate CSRF token for DELETE requests (make it optional for now)
    try:
        from flask_wtf.csrf import validate_csrf
        csrf_token = request.headers.get('X-CSRFToken')
        if csrf_token:
            validate_csrf(csrf_token)
        else:
            logger.warning("No CSRF token provided in request")
    except Exception as e:
        logger.warning(f"CSRF token validation failed: {e}")
        # Don't return error, just log the warning
    
    user_id = request.args.get('user_id')
    
    if not user_id or not user_id.strip():
        logger.warning("Invalid or missing user_id in delete_event request")
        return err("user_id is required and must not be empty", 400)
    
    if not event_id:
        logger.warning("Missing event_id in delete_event request")
        return err("event_id is required", 400)
    
    logger.info(f"Deleting event {event_id} for user: {user_id}")
    
    try:
        result = client.delete_event(event_id)
        
        if isinstance(result, dict) and "error" in result:
            logger.error(f"Error deleting event: {result['error']}")
            return err(result["error"], 404)
        
        logger.info(f"Successfully deleted event: {event_id}")
        return ok(result)
        
    except Exception as e:
        logger.error(f"Unexpected error in delete_event: {str(e)}")
        return err("Internal server error", 500)

# ---------------------------------------------------------------------
# Generate events using AI
# ---------------------------------------------------------------------
@events_bp.post("/generate-events")
def generate_events():
    """Generate events using AI."""
    # Validate CSRF token for POST requests (make it optional for now)
    try:
        from flask_wtf.csrf import validate_csrf
        csrf_token = request.headers.get('X-CSRFToken')
        if csrf_token:
            validate_csrf(csrf_token)
        else:
            logger.warning("No CSRF token provided in request")
    except Exception as e:
        logger.warning(f"CSRF token validation failed: {e}")
        # Don't return error, just log the warning
    
    user_data = parse_json(request)
    
    if not user_data:
        logger.warning("Missing request body in generate_events")
        return err("Request body is required", 400)
    
    logger.info("Generating events using AI")
    
    try:
        generated_events = event_generator.generate(user_data)
        
        # Check if generated_events is an error response
        if isinstance(generated_events, dict) and "error" in generated_events:
            logger.error(f"Error generating events: {generated_events['error']}")
            return err(generated_events["error"], 400)
        
        # Ensure generated_events is a list
        if not isinstance(generated_events, list):
            logger.error("Invalid response from event generator")
            return err("Invalid response from event generator", 500)
        
        if not generated_events:
            logger.warning("No events were generated")
            return err("No events were generated", 400)
        
        created_events = client.batch_create_events(generated_events)
        
        logger.info(f"Successfully generated and created events")
        return ok(created_events, 201)
        
    except Exception as e:
        logger.error(f"Unexpected error in generate_events: {str(e)}")
        return err("Internal server error", 500)

# ---------------------------------------------------------------------
# Test endpoints
# ---------------------------------------------------------------------
@events_bp.get("/test-static")
def test_static():
    """Test static file serving."""
    logger.info("Testing static file serving")
    return ok({
        "message": "Static file test endpoint",
        "static_url": "/static/css/calendar.css",
        "favicon_url": "/favicon.ico"
    })

@events_bp.get("/test")
def test_endpoint():
    """Simple test endpoint to verify calendar service is working."""
    logger.info("Test endpoint requested")
    return ok({
        "message": "Calendar service is working",
        "timestamp": datetime.utcnow().isoformat(),
        "calendar_client_initialized": True,  # Always initialized with new storage
        "event_generator_initialized": event_generator.initialized
    }) 
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\api\events.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\api\followups.py:
"""
Endpoints that generate and serve "event echo" follow-ups,
including compact Mermaid flowcharts.
"""

from __future__ import annotations

from flask import Blueprint, request
from markupsafe import Markup
import re
from datetime import timedelta, datetime

from calendar_integration.services.llm import generate_followups, generate_mermaid_flowchart
from calendar_integration.services.calendar_client import CalendarClient
from calendar_integration.utils.logger import get_logger
from calendar_integration.utils.datetime import parse_datetime
from calendar_integration.api._helpers import csrf_protect, ok, err, require_args

followups_bp = Blueprint("followups", __name__)
logger = get_logger(__name__)

client = CalendarClient()

# ---------------------------------------------------------------------
# Generate follow-up events and return them
# ---------------------------------------------------------------------
@followups_bp.post("/events/<string:event_id>/echo")
@require_args("user_id")
def create_echo(event_id: str):
    """Generate follow-up events for a given event, store them, and return Mermaid + new events."""
    user_id = request.args.get('user_id')
    if not user_id or not user_id.strip():
        logger.warning("Invalid or missing user_id in echo_event request")
        return err("user_id is required and must not be empty", 400)
    
    if not event_id:
        logger.warning("Missing event_id in echo_event request")
        return err("event_id is required", 400)
    
    user_id_str = user_id.strip()
    logger.info(f"Echo: Looking up parent event {event_id} for user: {user_id_str}")
    
    # Find the parent event
    events = client.fetch_events(user_id_str)
    parent_event = None
    for event in events:
        if isinstance(event, dict):
            event_id_from_data = event.get('id') or event.get('event_id')
            if str(event_id_from_data) == str(event_id):
                parent_event = event
                break
    
    if not parent_event or not isinstance(parent_event, dict):
        logger.warning(f"Parent event {event_id} not found for user: {user_id_str}")
        return err("Event not found", 404)
    
    # Generate follow-ups using LLM
    try:
        followup_text = generate_followups(
            parent_event.get('title', ''), 
            parent_event.get('start_time', ''), 
            parent_event.get('description', '')
        )
    except Exception as e:
        logger.error(f"Failed to generate follow-ups: {str(e)}")
        return err(f"OpenAI error (follow-up generation): {str(e)}", 500)
    
    # Parse follow-up events (reuse logic from llm_flowchart)
    followups = []
    sections = re.split(r'\n(?=\d+\.)', followup_text)
    
    for section in sections:
        if not section.strip():
            continue
        
        title_match = re.search(r'Title:\s*(.+?)(?:\n|$)', section, re.IGNORECASE)
        desc_match = re.search(r'Description:\s*(.+?)(?:\n|$)', section, re.IGNORECASE)
        date_match = re.search(r'Date:\s*(.+?)(?:\n|$)', section, re.IGNORECASE)
        
        if title_match and date_match:
            followups.append({
                "title": title_match.group(1).strip(),
                "description": desc_match.group(1).strip() if desc_match else "",
                "date": date_match.group(1).strip()
            })
    
    if len(followups) < 2:
        # fallback simple parsing
        followups = []
        lines = followup_text.strip().split('\n')
        current_followup = {}
        
        for line in lines:
            line = line.strip()
            if not line:
                continue
            
            if line.lower().startswith('title:'):
                if current_followup and 'title' in current_followup and 'date' in current_followup:
                    followups.append(current_followup)
                current_followup = {'title': line.split(':', 1)[1].strip()}
            elif line.lower().startswith('description:'):
                current_followup['description'] = line.split(':', 1)[1].strip()
            elif line.lower().startswith('date:'):
                current_followup['date'] = line.split(':', 1)[1].strip()
        
        if current_followup and 'title' in current_followup and 'date' in current_followup:
            followups.append(current_followup)
    
    if len(followups) < 2:
        logger.error(f"Failed to parse enough follow-ups. Got {len(followups)}, need 2. Text: {followup_text}")
        followups = [
            {"title": "Follow-up appointment", "description": "Check progress", "date": "1 week later"},
            {"title": "Final check", "description": "Ensure everything is fine", "date": "1 month later"}
        ]
    
    # Generate Mermaid code
    try:
        mermaid_code = generate_mermaid_flowchart(
            parent_event.get('title', ''), 
            parent_event.get('start_time', ''), 
            followups
        )
    except Exception as e:
        logger.error(f"Failed to generate Mermaid code: {str(e)}")
        return err(f"OpenAI error (Mermaid generation): {str(e)}", 500)
    
    # Insert each follow-up as a new event
    created = []
    # Parse original event's start/end and all_day
    orig_start = parent_event.get('start_time')
    orig_end = parent_event.get('end_time')
    orig_all_day = parent_event.get('all_day', False)
    
    # helper
    def _to_dt(value):
        if isinstance(value, datetime):
            return value
        if isinstance(value, str):
            try:
                return parse_datetime(value)
            except Exception:
                return None
        return None
    
    orig_start_dt = _to_dt(orig_start)
    orig_end_dt = _to_dt(orig_end)
    
    for f in followups:
        followup_date = f.get('date')
        try:
            followup_date_dt = parse_datetime(followup_date) if isinstance(followup_date, str) else None
        except Exception:
            followup_date_dt = None
        
        if orig_all_day or not orig_start_dt or not followup_date_dt:
            # All-day: end = next day
            start_time = followup_date if isinstance(followup_date, str) else ''
            if followup_date_dt:
                end_time = (followup_date_dt + timedelta(days=1)).date().isoformat()
            else:
                end_time = start_time
            all_day = True
        else:
            # Use original event's time, but on the follow-up date
            start_time_dt = followup_date_dt.replace(hour=orig_start_dt.hour, minute=orig_start_dt.minute, second=0, microsecond=0)
            if orig_end_dt:
                end_time_dt = followup_date_dt.replace(hour=orig_end_dt.hour, minute=orig_end_dt.minute, second=0, microsecond=0)
            else:
                end_time_dt = start_time_dt + timedelta(hours=1)
            start_time = start_time_dt.isoformat() if isinstance(start_time_dt, datetime) else str(start_time_dt)
            end_time = end_time_dt.isoformat() if isinstance(end_time_dt, datetime) else str(end_time_dt)
            all_day = False
        
        event_data = {
            'title': f.get('title', ''),
            'description': f.get('description', ''),
            'start_time': start_time,
            'end_time': end_time,
            'user_id': user_id_str,
            'all_day': all_day,
            'type': 'echo',
            'flowchart': mermaid_code
        }
        
        result = client.create_event(event_data)
        if isinstance(result, dict) and 'error' not in result:
            created.append(result)
    
    # Return Mermaid and new events
    return ok({
        'mermaid': mermaid_code,
        'events': created
    }, 201)

# ---------------------------------------------------------------------
# Return a Mermaid flowchart for an event chain
# ---------------------------------------------------------------------
@followups_bp.get("/events/<string:event_id>/flowchart")
def flowchart(event_id: str):
    """Generate a Mermaid flowchart for an event and two LLM-generated follow-ups."""
    data = request.get_json()
    if not data:
        return err("Missing request body", 400)

    # Extract event details
    event_title = data.get('title', '')
    event_date = data.get('date', '') or data.get('start_time', '')
    event_description = data.get('description', '')

    if not event_title or not event_date:
        return err("Event title and date are required", 400)

    # First LLM call: generate two follow-up events
    try:
        followup_text = generate_followups(event_title, event_date, event_description)
    except Exception as e:
        logger.error(f"Failed to generate follow-ups: {str(e)}")
        return err(f"OpenAI error (follow-up generation): {str(e)}", 500)

    # Parse follow-up events from LLM output with more flexible parsing
    followups = []
    
    # Split by numbers (1., 2., etc.) to handle various formats
    sections = re.split(r'\n(?=\d+\.)', followup_text)
    
    for section in sections:
        if not section.strip():
            continue
            
        # Extract title, description, and date more flexibly
        title_match = re.search(r'Title:\s*(.+?)(?:\n|$)', section, re.IGNORECASE)
        desc_match = re.search(r'Description:\s*(.+?)(?:\n|$)', section, re.IGNORECASE)
        date_match = re.search(r'Date:\s*(.+?)(?:\n|$)', section, re.IGNORECASE)
        
        if title_match and date_match:
            followups.append({
                "title": title_match.group(1).strip(),
                "description": desc_match.group(1).strip() if desc_match else "",
                "date": date_match.group(1).strip()
            })
    
    # If parsing failed, try a simpler approach
    if len(followups) < 2:
        logger.warning(f"Complex parsing failed, trying simple parsing. Original text: {followup_text}")
        followups = []
        lines = followup_text.strip().split('\n')
        current_followup = {}
        
        for line in lines:
            line = line.strip()
            if not line:
                continue
                
            if line.lower().startswith('title:'):
                if current_followup and 'title' in current_followup and 'date' in current_followup:
                    followups.append(current_followup)
                current_followup = {'title': line.split(':', 1)[1].strip()}
            elif line.lower().startswith('description:'):
                current_followup['description'] = line.split(':', 1)[1].strip()
            elif line.lower().startswith('date:'):
                current_followup['date'] = line.split(':', 1)[1].strip()
        
        # Add the last followup if valid
        if current_followup and 'title' in current_followup and 'date' in current_followup:
            followups.append(current_followup)
    
    # Ensure we have at least 2 follow-ups
    if len(followups) < 2:
        logger.error(f"Failed to parse enough follow-ups. Got {len(followups)}, need 2. Text: {followup_text}")
        # Create default follow-ups as fallback
        followups = [
            {"title": "Follow-up appointment", "description": "Check progress", "date": "1 week later"},
            {"title": "Final check", "description": "Ensure everything is fine", "date": "1 month later"}
        ]

    # Second LLM call: generate Mermaid flowchart code
    try:
        mermaid_code = generate_mermaid_flowchart(event_title, event_date, followups)
    except Exception as e:
        logger.error(f"Failed to generate Mermaid code: {str(e)}")
        return err(f"OpenAI error (Mermaid generation): {str(e)}", 500)

    return ok({
        "mermaid_code": mermaid_code,
        "followups": followups[:2],  # Ensure we only return 2 followups
        "llm_output": followup_text
    }) 
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\api\followups.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\api\models.py:
from calendar_integration.models import CalendarEvent

# Re-export for backward compatibility
__all__ = ['CalendarEvent']
# Calendar Models 
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\api\models.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\api\oauth_google.py:
"""
Google OAuth routes (PKCE).

Public routes
-------------
GET /calendar/oauth/google/start
GET /calendar/oauth/google/callback
"""

from __future__ import annotations

import logging
import secrets
import os
import json
from urllib.parse import urlencode

from flask import Blueprint, current_app, redirect, request, session, url_for

from calendar_integration.services.google_calendar_client import GoogleCalendarClient
from calendar_integration.api._helpers import err, ok

oauth_bp = Blueprint("oauth_google", __name__)

log = logging.getLogger("pitext_calendar.oauth")

# Test route to confirm blueprint registration
@oauth_bp.get("/oauth/test")
def test():
    return 'OAuth blueprint is working!'

# ---------------------------------------------------------------------
# Step 1: redirect user to Google consent page
# ---------------------------------------------------------------------
@oauth_bp.get("/oauth/google/start")
def oauth_start():
    current_app.logger.info('Google OAuth start endpoint called')
    google_auth_base = 'https://accounts.google.com/o/oauth2/v2/auth'
    client_id = os.getenv('GOOGLE_CLIENT_ID')
    # Use url_for to generate the callback URI
    redirect_uri = url_for('oauth_bp.oauth_callback', _external=True)
    scope = 'https://www.googleapis.com/auth/calendar.readonly'
    state = secrets.token_urlsafe(16)
    session['google_oauth_state'] = state
    session.modified = True

    params = {
        'client_id': client_id,
        'redirect_uri': redirect_uri,
        'response_type': 'code',
        'scope': scope,
        'access_type': 'offline',
        'prompt': 'consent',
        'state': state
    }
    consent_url = f"{google_auth_base}?{urlencode(params)}"
    current_app.logger.info(f'Redirecting to Google OAuth: {consent_url}')
    return redirect(consent_url)

# ---------------------------------------------------------------------
# Step 2: Google redirects back here with code
# ---------------------------------------------------------------------
@oauth_bp.get("/oauth/google/callback")
def oauth_callback():
    current_app.logger.info('Google OAuth callback endpoint called')
    state = request.args.get('state')
    if not state or state != session.get('google_oauth_state'):
        current_app.logger.error('Invalid state parameter')
        return 'Invalid state parameter', 400

    code = request.args.get('code')
    if not code:
        current_app.logger.error('Missing code parameter')
        return 'Missing code parameter', 400

    token_url = 'https://oauth2.googleapis.com/token'
    client_id = os.getenv('GOOGLE_CLIENT_ID')
    client_secret = os.getenv('GOOGLE_CLIENT_SECRET')
    redirect_uri = url_for('oauth_bp.oauth_callback', _external=True)

    data = {
        'code': code,
        'client_id': client_id,
        'client_secret': client_secret,
        'redirect_uri': redirect_uri,
        'grant_type': 'authorization_code',
    }
    try:
        import requests
        resp = requests.post(token_url, data=data)
        resp.raise_for_status()
        tokens = resp.json()
        current_app.logger.info(f'Token exchange successful: {tokens}')
        # Store tokens in google_tokens.json by user_id (from session or fallback)
        user_id = session.get('user_id', 'demo_user')
        token_path = os.path.join(os.path.dirname(__file__), '..', 'google_tokens.json')
        try:
            with open(token_path, 'r') as f:
                token_data = json.load(f)
        except Exception:
            token_data = {}
        token_data[user_id] = tokens
        with open(token_path, 'w') as f:
            json.dump(token_data, f, indent=2)
        # Redirect to calendar page with success indicator
        return redirect(url_for('events_bp.index', google_import='success'))
    except Exception as e:
        current_app.logger.error(f'Failed to exchange code for tokens: {e}')
        return f'Failed to exchange code for tokens: {e}', 500 
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\api\oauth_google.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\api\uploads.py:
"""
Serve uploaded attachments or large static blobs
that are not handled by Flask's normal static routing.
"""

from __future__ import annotations

from pathlib import Path
from flask import Blueprint, abort, send_from_directory

uploads_bp = Blueprint("uploads", __name__)

UPLOAD_ROOT = Path(__file__).parent.parent / "uploads"
UPLOAD_ROOT.mkdir(exist_ok=True)


@uploads_bp.get("/uploads/<path:filename>")
def serve_upload(filename: str):
    safe_path = (UPLOAD_ROOT / filename).resolve()
    if not safe_path.is_file() or UPLOAD_ROOT not in safe_path.parents:
        abort(404)
    return send_from_directory(UPLOAD_ROOT, safe_path.relative_to(UPLOAD_ROOT)) 
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\api\uploads.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\api\_helpers.py:
"""
Tiny, framework-free helpers for input validation, CSRF checks,
error responses and common JSON utilities.
"""

from __future__ import annotations

import functools
import json
import logging
from typing import Any, Callable, Dict, Tuple, TypeVar

from flask import Request, Response, abort, jsonify, request

JSONDict = Dict[str, Any]
_F = TypeVar("_F", bound=Callable[..., Response])

log = logging.getLogger("pitext_calendar.helpers")


# ---------------------------------------------------------------------
# CSRF protection (assumes cookie "csrftoken" and header "X-CSRFToken")
# ---------------------------------------------------------------------
def csrf_protect(view: _F) -> _F:  # type: ignore[misc]
    @functools.wraps(view)
    def _wrapped(*args, **kwargs):
        token_cookie = request.cookies.get("csrftoken")
        token_header = request.headers.get("X-CSRFToken")
        if token_cookie != token_header:
            log.warning("CSRF token mismatch")
            abort(403, description="CSRF verification failed")
        return view(*args, **kwargs)

    return _wrapped  # type: ignore[return-value]


# ---------------------------------------------------------------------
# JSON helpers
# ---------------------------------------------------------------------
def parse_json(req: Request) -> JSONDict:
    try:
        return req.get_json(force=True, silent=False)  # type: ignore[return-value]
    except Exception as exc:
        log.debug("Invalid JSON: %s", exc)
        abort(400, description="Malformed JSON")


def ok(data: Any = None, status: int = 200) -> tuple[Response, int]:
    payload = dict(data=data, status="success")
    return jsonify(payload), status


def err(message: str, status: int = 400) -> tuple[Response, int]:
    payload = dict(error=message, status="error")
    return jsonify(payload), status


# ---------------------------------------------------------------------
# Simple request arg validator
# ---------------------------------------------------------------------
def require_args(*arg_names: str) -> Callable[[_F], _F]:
    def _decorator(view: _F) -> _F:  # type: ignore[misc]
        @functools.wraps(view)
        def _wrapped(*args, **kwargs):
            missing = [k for k in arg_names if k not in request.args]
            if missing:
                abort(
                    400,
                    description=f"Missing query parameters: {', '.join(missing)}",
                )
            return view(*args, **kwargs)

        return _wrapped  # type: ignore[return-value]

    return _decorator 
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\api\_helpers.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\api\__init__.py:
"""
pitext_calendar.api package entry.

Creates the parent Flask Blueprint (`calendar_api`) and
registers the feature-specific blueprints found in sibling modules.
"""

from importlib import import_module
from pathlib import Path
from typing import Iterable

from flask import Blueprint

__all__ = ["calendar_api"]

# ---------------------------------------------------------------------
# Blueprint factory
# ---------------------------------------------------------------------

calendar_api = Blueprint(
    "calendar_api",
    __name__,
    static_folder=str(Path(__file__).parent.parent / "static"),
    static_url_path="/static",
    template_folder=str(Path(__file__).parent.parent / "templates"),
)

# List of sub-blueprint modules (do not include the leading package path)
_SUBMODULES: Iterable[str] = (
    "events",
    "followups",
    "uploads",
    "oauth_google",
)

for mod_name in _SUBMODULES:
    module = import_module(f"{__name__}.{mod_name}")
    # every sub-module must expose `<name>_bp`
    bp_attr = next(
        a for a in dir(module) if a.endswith("_bp")
    )
    sub_bp = getattr(module, bp_attr)
    calendar_api.register_blueprint(sub_bp, url_prefix="")

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\api\__init__.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\prompts\followup_events.txt:
You are an expert personal assistant and event planner. Given a calendar event, your job is to suggest two highly relevant follow-up events that would naturally occur after the original event. 

First, generate only the titles and short actionable descriptions (1-2 sentences) for the two follow-up events, based on the context and real-world timing. Do not generate dates yet.

Then, in a separate step, generate an appropriate future date (in ISO format, e.g., 2025-12-29) for each follow-up event, based on the context of the original event and typical real-world timing. For example, after a dentist appointment, a cleaning/check-up is usually scheduled 6 months later, and a follow-up for treatment is typically 1-2 weeks after the procedure. Please use realistic intervals for common scenarios.

Original event:
- Title: {title}
- Date: {date}
- Description: {description}

Format your response as:
1. Title: ...
   Description: ...
   Date: ...
2. Title: ...
   Description: ...
   Date: ...
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\prompts\followup_events.txt ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\prompts\mermaid_flowchart.txt:
You are a diagram generation assistant. Your task is to create a clear, readable Mermaid flowchart that visually represents a sequence of three events (the original and two follow-ups), each with a date and title. Use the following style:
- Each event is a subgraph labeled with its date.
- Each subgraph contains a box with the event title.
- Arrows connect the events in sequence.
- Use only valid Mermaid syntax.

Here are three events:
1. $original_title ($original_date)
2. $followup1_title ($followup1_date)
3. $followup2_title ($followup2_date)

Please generate a Mermaid flowchart in this style:

```mermaid
%%{init:{
  "theme":"base",
  "themeCSS": ".cluster.dateBox > rect{fill:#e8edf9;stroke:#4a6fa5;stroke-width:1.2px;rx:8!important;ry:8!important;}",
  "securityLevel": "loose"
}}%%

flowchart LR
    %% 1 style definition (everything after the first COMMA stays on the same line)
    classDef dateBox fill:#e8edf9,stroke:#4a6fa5,stroke-width:1.2px

    %% ––– diagram –––
    subgraph D1["$original_date_pretty"]
        EV0("$original_title")
    end
    class D1 dateBox

    subgraph D2["$followup1_date_pretty"]
        EV1("$followup1_title")
    end
    class D2 dateBox

    subgraph D3["$followup2_date_pretty"]
        EV2("$followup2_title")
    end
    class D3 dateBox

    EV0 --> EV1
    EV1 --> EV2

    %% Store ISO dates as comments for click handlers
    %% ISO_DATE_1: $original_date
    %% ISO_DATE_2: $followup1_date
    %% ISO_DATE_3: $followup2_date

    %% Clickable elements with ISO dates
    click EV0 "javascript:window.gotoDate('$original_date')"
    click EV1 "javascript:window.gotoDate('$followup1_date')"
    click EV2 "javascript:window.gotoDate('$followup2_date')"
    click D1 "javascript:window.gotoDate('$original_date')"
    click D2 "javascript:window.gotoDate('$followup1_date')"
    click D3 "javascript:window.gotoDate('$followup2_date')"
```
Replace the sample data with the actual event dates and titles. Only output the Mermaid code. 
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\prompts\mermaid_flowchart.txt ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\services\calendar_client.py:
"""
High-level calendar façade that hides the storage backend.

Public API
----------
CalendarClient.list_events(user_id)                 -> list[dict]
CalendarClient.create_event(payload)                -> dict
CalendarClient.update_event(event_id, payload)      -> dict
CalendarClient.delete_event(event_id)               -> None
CalendarClient.batch_upsert(events: list[dict])     -> dict[result]
"""

from __future__ import annotations

import logging
from typing import Any, Dict, List

log = logging.getLogger("pitext_calendar.calendar_client")


class CalendarClient:
    """Thread-safe singleton for event persistence."""

    def __init__(self, driver: str | None = None) -> None:
        # `driver` string lets you switch back-end (json, sql, redis, etc.)
        from ._storage import build_storage  # local import to avoid cycles

        self.storage = build_storage(driver or "json")  # type: ignore[arg-type]

    # -----------------------------------------------------------------
    # CRUD interface
    # -----------------------------------------------------------------
    def list_events(self, user_id: str | None) -> List[Dict[str, Any]]:
        return self.storage.fetch_all(user_id=user_id)

    def create_event(self, payload: Dict[str, Any]) -> Dict[str, Any]:
        event = self.storage.insert(payload)
        log.info("Created event %s", event["event_id"])
        return event

    def update_event(
        self, event_id: str, payload: Dict[str, Any]
    ) -> Dict[str, Any]:
        event = self.storage.update(event_id, payload)
        log.info("Updated event %s", event_id)
        return event

    def delete_event(self, event_id: str) -> None:
        self.storage.delete(event_id)
        log.info("Deleted event %s", event_id)

    # -----------------------------------------------------------------
    # Bulk insert / update
    # -----------------------------------------------------------------
    def batch_upsert(self, events: List[Dict[str, Any]]) -> Dict[str, Any]:
        return self.storage.batch_upsert(events)

    # -----------------------------------------------------------------
    # Backward compatibility methods
    # -----------------------------------------------------------------
    def fetch_events(self, user_id: str) -> List[Dict[str, Any]]:
        """Backward compatibility method."""
        return self.list_events(user_id)

    def batch_create_events(self, events: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Backward compatibility method."""
        result = self.batch_upsert(events)
        return result.get("created", []) 
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\services\calendar_client.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\services\event_generator.py:
# services/event_generator.py
from datetime import datetime, timedelta
from openai import OpenAI
import os
import re
from calendar_integration.models import CalendarEvent
from calendar_integration.utils.logger import get_logger

logger = get_logger(__name__)

class EventGenerator:
    def __init__(self):
        api_key = os.getenv('OPENAI_API_KEY')
        if api_key:
            self.client = OpenAI(api_key=api_key)
            self.initialized = True
            logger.info("Event generator initialized successfully")
        else:
            logger.warning("OpenAI API key not found - event generation will be disabled")
            self.client = None
            self.initialized = False

    def _parse_datetime_from_text(self, text: str, base_date: datetime) -> datetime:
        """Parse datetime from text using various patterns."""
        text = text.lower().strip()
        
        # Try to extract date/time patterns
        patterns = [
            r'(\d{1,2}):(\d{2})\s*(am|pm)?',  # Time patterns
            r'(\d{1,2})/(\d{1,2})/(\d{4})',   # Date patterns
            r'(\d{1,2})-(\d{1,2})-(\d{4})',   # Date patterns with dashes
            r'tomorrow',                       # Tomorrow
            r'next\s+(\w+)',                   # Next day of week
            r'in\s+(\d+)\s+days?',             # In X days
        ]
        
        for pattern in patterns:
            match = re.search(pattern, text)
            if match:
                if 'tomorrow' in text:
                    return base_date + timedelta(days=1)
                elif 'next' in text:
                    # Simple implementation - could be enhanced
                    return base_date + timedelta(days=1)
                elif 'in' in text and 'days' in text:
                    days = int(match.group(1))
                    return base_date + timedelta(days=days)
        
        # Default to tomorrow if no pattern found
        return base_date + timedelta(days=1)

    def generate(self, user_data: dict):
        if not self.initialized or not self.client:
            logger.error("Event generator not initialized")
            return {"error": "Event generator not initialized - check OpenAI API key"}
        
        try:
            interests = user_data.get('interests', [])
            today = datetime.utcnow()
            generated_events = []

            prompt = f"""Generate 3-5 calendar events based on these interests: {', '.join(interests)}. 
            For each event, provide:
            - Title: [event title]
            - Description: [brief description]
            - Date: [specific date or relative date like 'tomorrow', 'next Monday', 'in 3 days']
            - Time: [specific time like '2:00 PM' or '14:00']
            - Duration: [duration in hours, default 1 hour]
            - Location: [location or 'Online' if virtual]
            
            Format each event with clear labels."""

            logger.info(f"Generating events for interests: {interests}")
            
            try:
                response = self.client.chat.completions.create(
                    model="gpt-4.1",
                    messages=[
                        {"role": "system", "content": "You are an AI assistant creating structured calendar events. Always provide complete event details with clear formatting."},
                        {"role": "user", "content": prompt}
                    ],
                    max_tokens=800
                )
            except Exception as api_error:
                error_msg = str(api_error)
                if "rate_limit" in error_msg.lower() or "429" in error_msg:
                    logger.error("OpenAI API rate limit exceeded")
                    return {"error": "Rate limit exceeded. Please try again later."}
                elif "authentication" in error_msg.lower() or "401" in error_msg:
                    logger.error("OpenAI API authentication failed")
                    return {"error": "OpenAI API authentication failed. Check your API key."}
                elif "quota" in error_msg.lower():
                    logger.error("OpenAI API quota exceeded")
                    return {"error": "OpenAI API quota exceeded. Please check your account."}
                else:
                    logger.error(f"OpenAI API error: {error_msg}")
                    return {"error": f"OpenAI API error: {error_msg}"}

            content = response.choices[0].message.content
            if not content:
                logger.warning("Empty response from OpenAI")
                return generated_events

            # Split content into individual events
            event_blocks = content.split('\n\n')
            
            for block in event_blocks:
                if not block.strip():
                    continue
                    
                try:
                    # Parse event details
                    lines = [line.strip() for line in block.split('\n') if line.strip()]
                    
                    title = ""
                    description = ""
                    date_str = ""
                    time_str = ""
                    duration = 1  # default 1 hour
                    location = ""
                    
                    for line in lines:
                        if line.startswith('Title:'):
                            title = line.replace('Title:', '').strip()
                        elif line.startswith('Description:'):
                            description = line.replace('Description:', '').strip()
                        elif line.startswith('Date:'):
                            date_str = line.replace('Date:', '').strip()
                        elif line.startswith('Time:'):
                            time_str = line.replace('Time:', '').strip()
                        elif line.startswith('Duration:'):
                            duration_str = line.replace('Duration:', '').strip()
                            try:
                                duration = int(duration_str.split()[0])  # Extract number from "2 hours"
                            except:
                                duration = 1
                        elif line.startswith('Location:'):
                            location = line.replace('Location:', '').strip()
                    
                    if not title:
                        continue
                        
                    # Parse start time
                    start_time = self._parse_datetime_from_text(f"{date_str} {time_str}", today)
                    
                    # Calculate end time based on duration
                    end_time = start_time + timedelta(hours=duration)
                    
                    event = CalendarEvent(
                        title=title,
                        description=description,
                        start_time=start_time,
                        end_time=end_time,
                        location=location or "TBD"
                    )
                    
                    generated_events.append(event.to_dict())
                    logger.info(f"Generated event: {title}")
                    
                except Exception as e:
                    logger.error(f"Failed to parse event block: {e}")
                    continue

            logger.info(f"Successfully generated {len(generated_events)} events")
            return generated_events
            
        except Exception as e:
            logger.error(f"Failed to generate events: {str(e)}")
            return {"error": f"Failed to generate events: {str(e)}"}
# Event Generator Service 
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\services\event_generator.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\services\google_calendar_client.py:
"""
Minimal Google Calendar API wrapper (OAuth token exchanged elsewhere).

Only the subset needed by the app is implemented.
"""

from __future__ import annotations

import json
import logging
import os
from pathlib import Path
from typing import Dict

import google.auth.transport.requests
import google.oauth2.credentials
import googleapiclient.discovery

log = logging.getLogger("pitext_calendar.google_client")

_TOKEN_DIR = Path.home() / ".pitext" / "google_tokens"
_TOKEN_DIR.mkdir(parents=True, exist_ok=True)


class GoogleCalendarClient:
    """Handles URL generation, token exchange, and simple event ops."""

    SCOPES = ["https://www.googleapis.com/auth/calendar.events"]

    def __init__(self) -> None:
        self.client_id = os.getenv("GOOGLE_CLIENT_ID")
        self.client_secret = os.getenv("GOOGLE_CLIENT_SECRET")
        if not self.client_id or not self.client_secret:
            raise RuntimeError("Google OAuth env vars missing")

    # --------------------------------------------------------------
    # OAuth helpers
    # --------------------------------------------------------------
    def get_authorize_url(self, state: str) -> str:
        from google_auth_oauthlib.flow import Flow

        flow = Flow.from_client_config(
            {
                "installed": {
                    "client_id": self.client_id,
                    "client_secret": self.client_secret,
                    "redirect_uris": ["urn:ietf:wg:oauth:2.0:oob", "http://localhost"],
                    "auth_uri": "https://accounts.google.com/o/oauth2/auth",
                    "token_uri": "https://oauth2.googleapis.com/token",
                }
            },
            scopes=self.SCOPES,
            state=state,
        )
        return flow.authorization_url(prompt="consent")[0]

    def exchange_code(self, code: str) -> Dict:
        from google_auth_oauthlib.flow import Flow

        flow = Flow.from_client_config(
            {
                "installed": {
                    "client_id": self.client_id,
                    "client_secret": self.client_secret,
                    "redirect_uris": ["urn:ietf:wg:oauth:2.0:oob", "http://localhost"],
                    "auth_uri": "https://accounts.google.com/o/oauth2/auth",
                    "token_uri": "https://oauth2.googleapis.com/token",
                }
            },
            scopes=self.SCOPES,
        )
        flow.fetch_token(code=code)
        creds = flow.credentials
        return {
            "access_token": creds.token,
            "refresh_token": creds.refresh_token,
            "expiry": creds.expiry.isoformat() if creds.expiry else None,
        }

    # --------------------------------------------------------------
    # High-level persistence
    # --------------------------------------------------------------
    def persist_tokens(self, user_id: str, tokens: Dict) -> None:
        token_path = _TOKEN_DIR / f"{user_id}.json"
        token_path.write_text(json.dumps(tokens, indent=2))
        log.info("Saved tokens for %s", user_id)

    # --------------------------------------------------------------
    # Example: insert an event directly on Google
    # --------------------------------------------------------------
    def insert_event(self, user_id: str, event_payload: Dict) -> Dict:
        creds = self._load_creds(user_id)
        service = googleapiclient.discovery.build(
            "calendar", "v3", credentials=creds, cache_discovery=False
        )
        result = service.events().insert(calendarId="primary", body=event_payload).execute()
        return result

    # --------------------------------------------------------------
    # Helpers
    # --------------------------------------------------------------
    def _load_creds(self, user_id: str):
        token_path = _TOKEN_DIR / f"{user_id}.json"
        if not token_path.exists():
            raise RuntimeError("User has not linked Google Calendar")
        with token_path.open() as f:
            data = json.load(f)
        creds = google.oauth2.credentials.Credentials(
            token=data["access_token"],
            refresh_token=data["refresh_token"],
            token_uri="https://oauth2.googleapis.com/token",
            client_id=self.client_id,
            client_secret=self.client_secret,
            scopes=self.SCOPES,
        )
        if creds.expired and creds.refresh_token:
            creds.refresh(google.auth.transport.requests.Request())
            self.persist_tokens(user_id, {
                "access_token": creds.token,
                "refresh_token": creds.refresh_token,
                "expiry": creds.expiry.isoformat() if creds.expiry else None,
            })
        return creds

    def fetch_events(self, user_id: str, calendar_id='primary', time_min=None, time_max=None, max_results=100):
        # Fetch events from the user's Google Calendar
        creds = self._load_creds(user_id)
        service = googleapiclient.discovery.build(
            "calendar", "v3", credentials=creds, cache_discovery=False
        )
        from datetime import datetime
        events_result = service.events().list(
            calendarId=calendar_id,
            timeMin=time_min or datetime.utcnow().isoformat() + 'Z',
            timeMax=time_max,
            maxResults=max_results,
            singleEvents=True,
            orderBy='startTime'
        ).execute()
        return events_result.get('items', []) 
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\services\google_calendar_client.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\services\llm.py:
import os
from openai import OpenAI
from string import Template

PROMPT_DIR = os.path.join(os.path.dirname(__file__), '..', 'prompts')

def load_prompt(filename):
    path = os.path.join(PROMPT_DIR, filename)
    with open(path, 'r', encoding='utf-8') as f:
        return f.read()

def get_openai_client():
    api_key = os.getenv('OPENAI_API_KEY')
    if not api_key:
        raise RuntimeError('OpenAI API key not configured')
    return OpenAI(api_key=api_key)

def generate_followups(event_title, event_date, event_description):
    client = get_openai_client()
    prompt_template = load_prompt('followup_events.txt')
    
    # Format the prompt with the event details
    formatted_prompt = prompt_template.format(
        title=event_title, 
        date=event_date, 
        description=event_description
    )
    
    response = client.chat.completions.create(
        model="gpt-4.1",
        messages=[
            {"role": "system", "content": "You are an expert personal assistant and event planner."},
            {"role": "user", "content": formatted_prompt}
        ],
        max_tokens=500
    )
    content = response.choices[0].message.content
    return content.strip() if content else ""

def generate_mermaid_flowchart(event_title, event_date, followups):
    client = get_openai_client()
    prompt_template = load_prompt('mermaid_flowchart.txt')
    
    # Helper function to prettify dates
    def prettify_date(iso_date):
        try:
            from datetime import datetime
            dt = datetime.fromisoformat(iso_date.replace('Z', '+00:00'))
            return dt.strftime('%d %b %Y')
        except:
            return iso_date
    
    # Use string.Template for formatting with both ISO and pretty dates
    tmpl = Template(prompt_template)
    formatted_prompt = tmpl.safe_substitute(
        original_title=event_title,
        original_date=event_date,
        original_date_pretty=prettify_date(event_date),
        followup1_title=followups[0]['title'],
        followup1_date=followups[0]['date'],
        followup1_date_pretty=prettify_date(followups[0]['date']),
        followup2_title=followups[1]['title'],
        followup2_date=followups[1]['date'],
        followup2_date_pretty=prettify_date(followups[1]['date'])
    )
    response = client.chat.completions.create(
        model="gpt-4.1",
        messages=[
            {"role": "system", "content": "You are a diagram generation assistant."},
            {"role": "user", "content": formatted_prompt}
        ],
        max_tokens=500
    )
    content = response.choices[0].message.content
    return content.strip() if content else "" 
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\services\llm.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\services\_storage.py:
"""
Storage backend abstraction for calendar events.
Currently implements JSON file storage, but can be extended to support
SQL databases, Redis, etc.
"""

from __future__ import annotations

import json
import logging
import os
from datetime import datetime
from typing import Any, Dict, List

from ..utils.datetime import parse_datetime

log = logging.getLogger("pitext_calendar.storage")


class JSONStorage:
    """Simple JSON file-based storage backend."""
    
    def __init__(self, file_path: str = "calendar_events.json"):
        self.file_path = file_path
        self._ensure_file_exists()
    
    def _ensure_file_exists(self):
        """Create the JSON file if it doesn't exist."""
        if not os.path.exists(self.file_path):
            with open(self.file_path, 'w') as f:
                json.dump([], f)
            log.info(f"Created events file: {self.file_path}")
    
    def _load_events(self) -> List[Dict[str, Any]]:
        """Load events from JSON file."""
        try:
            if os.path.exists(self.file_path):
                with open(self.file_path, 'r') as f:
                    events_data = json.load(f)
                    # Convert string dates back to datetime objects
                    for event in events_data:
                        datetime_fields = ['start_time', 'end_time', 'created', 'last_modified']
                        for field in datetime_fields:
                            if isinstance(event.get(field), str):
                                try:
                                    event[field] = parse_datetime(event[field])
                                except ValueError as e:
                                    log.warning(f"Failed to parse datetime for field {field}: {e}")
                                    event[field] = datetime.now()
                    return events_data
            return []
        except json.JSONDecodeError as e:
            log.error(f"Failed to parse events file (corrupted JSON): {e}")
            # Backup corrupted file and create new one
            try:
                backup_file = f"{self.file_path}.backup.{int(datetime.now().timestamp())}"
                os.rename(self.file_path, backup_file)
                log.info(f"Backed up corrupted file to: {backup_file}")
            except Exception as backup_error:
                log.error(f"Failed to backup corrupted file: {backup_error}")
            return []
        except Exception as e:
            log.error(f"Failed to load events from file: {e}")
            return []
    
    def _save_events(self, events: List[Dict[str, Any]]):
        """Save events to JSON file."""
        try:
            # Convert datetime objects to strings for JSON serialization
            events_to_save = []
            for event in events:
                event_copy = event.copy()
                # Handle all datetime fields
                datetime_fields = ['start_time', 'end_time', 'created', 'last_modified']
                for field in datetime_fields:
                    if isinstance(event_copy.get(field), datetime):
                        event_copy[field] = event_copy[field].isoformat()
                events_to_save.append(event_copy)
            
            with open(self.file_path, 'w') as f:
                json.dump(events_to_save, f, indent=2)
        except Exception as e:
            log.error(f"Failed to save events to file: {e}")
    
    def fetch_all(self, user_id: str | None = None) -> List[Dict[str, Any]]:
        """Fetch all events, optionally filtered by user_id."""
        events = self._load_events()
        if user_id:
            events = [event for event in events if event.get('user_id') == user_id]
        return events
    
    def insert(self, payload: Dict[str, Any]) -> Dict[str, Any]:
        """Insert a new event."""
        events = self._load_events()
        
        # Generate unique event ID
        import uuid
        event_id = str(uuid.uuid4())
        
        # Create event with metadata
        event = {
            'created': datetime.now(),
            'last_modified': datetime.now(),
            **payload,
            'event_id': event_id,  # Put this AFTER payload to override empty string
        }
        
        events.append(event)
        self._save_events(events)
        return event
    
    def update(self, event_id: str, payload: Dict[str, Any]) -> Dict[str, Any]:
        """Update an existing event."""
        events = self._load_events()
        
        for i, event in enumerate(events):
            if event.get('event_id') == event_id:
                events[i].update(payload)
                events[i]['last_modified'] = datetime.now()
                self._save_events(events)
                return events[i]
        
        raise ValueError(f"Event not found: {event_id}")
    
    def delete(self, event_id: str):
        """Delete an event."""
        events = self._load_events()
        events = [event for event in events if event.get('event_id') != event_id]
        self._save_events(events)
    
    def batch_upsert(self, events: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Batch insert/update events."""
        created = []
        errors = []
        
        for i, data in enumerate(events):
            try:
                if 'event_id' in data:
                    # Update existing event
                    updated_event = self.update(data['event_id'], data)
                    created.append(updated_event)
                else:
                    # Create new event
                    new_event = self.insert(data)
                    created.append(new_event)
            except Exception as e:
                errors.append(f"Event {i}: {str(e)}")
        
        return {
            "created": created,
            "errors": errors,
            "message": f"Processed {len(created)} events with {len(errors)} errors"
        }


def build_storage(driver: str) -> JSONStorage:
    """Factory function to create storage backends."""
    if driver == "json":
        return JSONStorage()
    else:
        raise ValueError(f"Unknown storage driver: {driver}") 
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\services\_storage.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\services\__init__.py:
# services/__init__.py
from .calendar_client import CalendarClient
from .event_generator import EventGenerator
from .google_calendar_client import GoogleCalendarClient
from .event_generation import EventEchoService

__all__ = [
    "CalendarClient",
    "EventGenerator", 
    "GoogleCalendarClient",
    "EventEchoService"
]
# Services Module 
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\services\__init__.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\services\event_generation\openai_client.py:
"""
Thin wrapper around OpenAI Chat Completions.

The goal is to isolate any vendor SDK logic so
the rest of the codebase remains import-free.
"""

from __future__ import annotations

import logging
import os
from typing import Dict

from openai import OpenAI

log = logging.getLogger("pitext_calendar.openai_client")


class ChatCompletionClient:
    """Very small abstraction over openai.ChatCompletion.create"""

    def __init__(self, model: str = "gpt-4.1") -> None:
        api_key = os.getenv("OPENAI_API_KEY")
        if not api_key:
            raise RuntimeError("OPENAI_API_KEY not set")
        self.client = OpenAI(api_key=api_key)
        self.model = model

    def chat(self, prompt: str) -> str:
        log.debug("Calling OpenAI, model=%s, prompt=%s", self.model, prompt[:80])
        response = self.client.chat.completions.create(
            model=self.model,
            messages=[{"role": "user", "content": prompt}],
            temperature=0.3,
        )
        content = response.choices[0].message.content
        if content is None:
            raise RuntimeError("OpenAI returned empty response")
        return content 
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\services\event_generation\openai_client.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\services\event_generation\parser.py:
"""
Parses OpenAI responses into structured follow-up events or Mermaid code.
"""

from __future__ import annotations

import json
import logging
from typing import Any, Dict, List

log = logging.getLogger("pitext_calendar.echo_parser")


class EchoParser:
    """Convert raw LLM output to domain objects."""

    # -----------------------------------------------------------------
    # Events
    # -----------------------------------------------------------------
    def to_events(
        self, raw: str, user_id: str | None = None
    ) -> List[Dict[str, Any]]:
        try:
            parsed = json.loads(raw)
            assert isinstance(parsed, list)
        except Exception as exc:
            log.error("Cannot parse events JSON: %s", exc)
            raise ValueError("Bad event JSON") from exc

        for ev in parsed:
            ev.setdefault("user_id", user_id)
        return parsed  # type: ignore[return-value]

    # -----------------------------------------------------------------
    # Mermaid
    # -----------------------------------------------------------------
    def to_mermaid(self, raw: str) -> str:
        # allow either code-block fenced or plain
        lines = raw.strip().splitlines()
        if lines[0].startswith("```"):
            lines = lines[1:]
        if lines[-1].startswith("```"):
            lines = lines[:-1]
        return "\n".join(lines) 
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\services\event_generation\parser.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\services\event_generation\prompt_builder.py:
"""
Prompt factory for the Event Echo feature.
Keeps all wording templates in one file so they can be tuned
without touching network or parsing code.
"""

from __future__ import annotations

from pathlib import Path
from string import Template

_BASE_DIR = Path(__file__).parent
_PROMPT_FILE = _BASE_DIR / "templates" / "echo_prompt.tmpl"

_DEFAULT_TEMPLATE = Template(
    """You are an assistant that proposes follow-up calendar events.
Seed event ID: $event_id
Output JSON with keys: title, offset_days, duration_minutes."""
)

# preload file template if exists
_PROMPT_TMPL: Template
try:
    _PROMPT_TMPL = Template(_PROMPT_FILE.read_text(encoding="utf-8"))
except FileNotFoundError:
    _PROMPT_TMPL = _DEFAULT_TEMPLATE


def build_prompt(
    seed_event_id: str,
    mermaid_only: bool = False,
) -> str:
    if mermaid_only:
        return (
            "Produce only Mermaid flowchart, no prose. "
            f"Seed event ID: {seed_event_id}"
        )
    return _PROMPT_TMPL.safe_substitute(event_id=seed_event_id) 
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\services\event_generation\prompt_builder.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\services\event_generation\service.py:
"""
Orchestrates prompt creation, OpenAI completion, and parsing
to return AI-generated follow-up events plus Mermaid code.
"""

from __future__ import annotations

import logging
from dataclasses import dataclass, field
from typing import Any, Dict, List

from .prompt_builder import build_prompt
from .openai_client import ChatCompletionClient
from .parser import EchoParser

log = logging.getLogger("pitext_calendar.echo_service")


@dataclass(slots=True)
class EventEchoService:
    """
    Glue object that the API layer calls.
    All network / AI calls happen here, not in the Flask code.
    """

    model: str = "gpt-4.1"
    openai: Any = field(init=False)
    parser: Any = field(init=False)

    def __post_init__(self) -> None:
        self.openai = ChatCompletionClient(model=self.model)
        self.parser = EchoParser()

    # --------------------------------------------------------------
    # Public API
    # --------------------------------------------------------------
    def generate_followups(
        self, user_id: str | None, seed_event_id: str
    ) -> List[Dict[str, Any]]:
        prompt = build_prompt(seed_event_id)
        completion = self.openai.chat(prompt)
        events = self.parser.to_events(completion, user_id=user_id)
        log.debug("Generated %d follow-ups", len(events))
        return events

    def mermaid_for_chain(self, seed_event_id: str) -> str:
        prompt = build_prompt(seed_event_id, mermaid_only=True)
        completion = self.openai.chat(prompt)
        mermaid = self.parser.to_mermaid(completion)
        return mermaid 
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\services\event_generation\service.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\services\event_generation\__init__.py:
"""
Aggregate import layer: `from pitext_calendar.services.event_generation import EventEchoService`
"""

from .service import EventEchoService  # re-export

__all__ = ["EventEchoService"] 
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\services\event_generation\__init__.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\static\css\calendar-dark-theme.css:
/* ───────────────────────────────────────────────────────────────
   Pitext Calendar – Dark Theme v2  (2025‑07‑01)
   • Removes purple gradient side‑bars by forcing a flat black body background
   • Inverts calendar grid (white cells, black text)
   • Keeps yellow accent + dark panels elsewhere
   Place file at: calendar_integration/static/css/calendar-dark-theme.css
   ─────────────────────────────────────────────────────────────── */

/* ===== 1. Brand tokens ======================================= */
:root {
  --pitext-accent: #facf0f;          /* signature yellow */
  --pitext-bg: #000000;              /* deepest background */
  --pitext-bg-alt: #0e0e0e;          /* panel background */
  --pitext-text-dark: #000000;
  --pitext-text-light: #ffffff;
  --pitext-border-radius: 8px;
  --pitext-glow: 0 0 8px var(--pitext-accent);
}

/* ===== 2. Global background override ======================== */
/* Force‑override any page‑level gradient so side bars disappear */
html, body, #app, .page-wrapper, .layout, .container-fluid {
  background: var(--pitext-bg) !important;
  color: var(--pitext-text-light);
  font-family: "Inter", system-ui, sans-serif;
}

/* Optional: comment the lightbulb overlay back in if you want it */
/* .lightbulb-bg { … } */

/* ===== 3. FullCalendar header ================================= */
.fc-toolbar-title {
  color: var(--pitext-accent);
  font-weight: 600;
}

.fc-button {
  background: #5667d7;                  /* muted indigo same as desktop UI */
  color: var(--pitext-text-light);
  border: none;
  border-radius: var(--pitext-border-radius);
  padding: 0.35rem 0.75rem;
  box-shadow: var(--pitext-glow);
  transition: filter .15s ease-in;
}
.fc-button-primary:not(:disabled):hover,
.fc-button-primary:not(:disabled):focus {
  filter: brightness(1.1);
}

/* ===== 4. Grid swap: white cells / black text =============== */
.fc-theme-standard .fc-scrollgrid,
.fc-theme-standard td,
.fc-theme-standard th {
  background-color: #ffffff;            /* white cell */
  border-color: rgba(0,0,0,0.12);
  color: var(--pitext-text-dark);
}
.fc-col-header-cell {
  background-color: #ffffff;
  color: var(--pitext-text-dark);
  font-weight: 600;
}
.fc-day-other {
  background-color: #fafafa;            /* subtle diff for prev/next month */
  color: rgba(0,0,0,0.25);
}
.fc-daygrid-day-number {
  color: var(--pitext-text-dark);
}

/* ===== 5. Event chips ======================================= */
.fc-event {
  background-color: var(--pitext-accent);
  color: var(--pitext-text-dark);
  border: none;
  border-radius: var(--pitext-border-radius);
  font-weight: 500;
  box-shadow: 0 1px 2px rgba(0,0,0,0.4);
}
.fc-event[data-type="echo"] {
  background-image: linear-gradient(135deg, var(--pitext-accent) 0%, #ff758c 100%);
  color: var(--pitext-text-light);
}

/* ===== 6. Modal ============================================ */
.modal-content {
  background: rgba(14,14,14,0.96);
  backdrop-filter: blur(8px);
  border: 1px solid var(--pitext-accent);
  border-radius: calc(var(--pitext-border-radius) * 1.25);
  color: var(--pitext-text-light);
}
.modal-header .modal-title {
  color: var(--pitext-accent);
}
.btn-primary {
  background: var(--pitext-accent);
  border: none;
  color: var(--pitext-text-dark);
}
.btn-primary:hover { filter: brightness(1.1); }

/* ===== 7. Mermaid flowchart shapes ========================= */
.mermaid svg .cluster.dateBox > rect,
.mermaid svg .node rect {
  fill: var(--pitext-bg-alt) !important;
  stroke: var(--pitext-accent) !important;
  stroke-width: 1.6px;
  rx: var(--pitext-border-radius); ry: var(--pitext-border-radius);
}
.mermaid svg .edgePath path { stroke: var(--pitext-accent) !important; }

/* ===== 8. Scrollbar (WebKit) ================================ */
::-webkit-scrollbar { width: 8px; }
::-webkit-scrollbar-thumb {
  background: var(--pitext-accent);
  border-radius: 4px;
}

/* ===== 9. Utility classes ==================================== */
.text-accent   { color: var(--pitext-accent) !important; }
.bg-panel      { background: var(--pitext-bg-alt) !important; }
.rounded-soft  { border-radius: var(--pitext-border-radius) !important; }
.shadow-glow   { box-shadow: var(--pitext-glow) !important; } 
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\static\css\calendar-dark-theme.css ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\static\css\calendar.css:
/* Calendar CSS for PiText Calendar */

/* Reset and base styles */
* {
    box-sizing: border-box;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
    margin: 0;
    padding: 0;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    min-height: 100vh;
}

.container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
    background: white;
    min-height: 100vh;
    box-shadow: 0 0 20px rgba(0,0,0,0.1);
}

/* Header styles */
header {
    text-align: center;
    margin-bottom: 30px;
    padding: 20px 0;
    border-bottom: 2px solid #f0f0f0;
}

header h1 {
    color: #667eea;
    margin-bottom: 10px;
    font-size: 2.5rem;
    font-weight: 700;
}

header p {
    color: #666;
    font-size: 1.1rem;
    margin: 0;
}

/* Calendar container */
#calendar {
    background: white;
    border-radius: 12px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.1);
    overflow: hidden;
    margin-bottom: 30px;
}

/* FullCalendar customizations */
.fc {
    font-family: inherit;
}

.fc-toolbar {
    background: #f8f9fa;
    padding: 15px 20px;
    border-bottom: 1px solid #e9ecef;
}

.fc-toolbar-title {
    font-size: 1.5rem !important;
    font-weight: 600;
    color: #495057;
}

.fc-button {
    background: #667eea !important;
    border-color: #667eea !important;
    color: white !important;
    font-weight: 500;
    padding: 8px 16px;
    border-radius: 6px;
    transition: all 0.3s ease;
}

.fc-button:hover {
    background: #5a67d8 !important;
    border-color: #5a67d8 !important;
    transform: translateY(-1px);
}

.fc-button:focus {
    box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.3);
}

.fc-button-active {
    background: #5a67d8 !important;
    border-color: #5a67d8 !important;
}

/* Event styling */
.fc-event {
    border-radius: 6px;
    border: none;
    font-weight: 500;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    transition: all 0.3s ease;
}

.fc-event:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
}

.event-content {
    padding: 4px 8px;
}

.event-title {
    font-weight: 600;
    margin-bottom: 2px;
}

.event-location {
    font-size: 0.85rem;
    opacity: 0.9;
}

/* Modal styles - improved compactness and spacing */
.calendar-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.5);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10000;
    animation: fadeIn 0.3s ease;
}

.modal-content {
    background: white;
    border-radius: 12px;
    box-shadow: 0 10px 40px rgba(0,0,0,0.2);
    max-width: 650px;
    min-width: 400px;
    width: 95%;
    max-height: 90vh;
    overflow-y: visible;
    padding: 0;
}

.modal-header {
    padding: 16px 20px 10px 20px;
    border-bottom: 1px solid #e9ecef;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.modal-header h3 {
    margin: 0;
    color: #495057;
    font-size: 1.3rem;
}

.close-btn {
    background: none;
    border: none;
    font-size: 24px;
    color: #6c757d;
    cursor: pointer;
    padding: 0;
    width: 30px;
    height: 30px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    transition: all 0.3s ease;
}

.close-btn:hover {
    background: #f8f9fa;
    color: #495057;
}

.modal-body {
    padding: 16px 20px 10px 20px;
    max-height: 55vh;
    overflow-y: auto;
}

.modal-footer {
    padding: 12px 20px 16px 20px;
    border-top: 1px solid #e9ecef;
    display: flex;
    gap: 10px;
    justify-content: flex-end;
}

/* Form styles */
.form-group {
    margin-bottom: 12px;
}

.form-group label {
    margin-bottom: 4px;
    font-size: 1rem;
}

.form-group input,
.form-group textarea,
.form-group select {
    padding: 8px 12px;
    font-size: 1rem;
    border-radius: 6px;
}

.form-group textarea {
    min-height: 60px;
}

/* Button styles */
.save-btn,
.edit-btn {
    background: #667eea;
    color: white;
    border: none;
    padding: 12px 24px;
    border-radius: 8px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
}

.save-btn:hover,
.edit-btn:hover {
    background: #5a67d8;
    transform: translateY(-1px);
}

.cancel-btn {
    background: #6c757d;
    color: white;
    border: none;
    padding: 12px 24px;
    border-radius: 8px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
}

.cancel-btn:hover {
    background: #5a6268;
    transform: translateY(-1px);
}

.delete-btn {
    background: #dc3545;
    color: white;
    border: none;
    padding: 12px 24px;
    border-radius: 8px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
}

.delete-btn:hover {
    background: #c82333;
    transform: translateY(-1px);
}

/* Test controls */
.test-controls {
    margin-top: 30px;
    padding: 25px;
    background: #f8f9fa;
    border-radius: 12px;
    border: 2px solid #e9ecef;
    display: none;
}

.test-controls h3 {
    margin-top: 0;
    color: #495057;
    font-size: 1.2rem;
    margin-bottom: 15px;
}

.test-controls button {
    margin: 5px;
    padding: 12px 20px;
    background: #667eea;
    color: white;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-weight: 600;
    transition: all 0.3s ease;
}

.test-controls button:hover {
    background: #5a67d8;
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
}

/* Loading state */
.loading {
    position: relative;
}

.loading::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(255,255,255,0.8);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
}

/* Animations */
@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}

@keyframes slideUp {
    from { 
        opacity: 0;
        transform: translateY(30px);
    }
    to { 
        opacity: 1;
        transform: translateY(0);
    }
}

@keyframes slideIn {
    from {
        opacity: 0;
        transform: translateX(100%);
    }
    to {
        opacity: 1;
        transform: translateX(0);
    }
}

/* Responsive design */
@media (max-width: 768px) {
    .container {
        padding: 10px;
    }
    
    header h1 {
        font-size: 2rem;
    }
    
    .fc-toolbar {
        flex-direction: column;
        gap: 10px;
    }
    
    .fc-toolbar-chunk {
        display: flex;
        justify-content: center;
    }
    
    .modal-content {
        max-width: 98vw;
        min-width: 0;
        width: 98vw;
        margin: 10px;
    }
    
    .modal-footer {
        flex-direction: column;
    }
    
    .test-controls button {
        width: 100%;
        margin: 5px 0;
    }
    
    .modal-body {
        max-height: 60vh;
    }
}

/* Error notification styles */
.calendar-error-notification {
    position: fixed;
    top: 20px;
    right: 20px;
    background: #ff6b6b;
    color: white;
    padding: 15px 20px;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    z-index: 10000;
    max-width: 300px;
    animation: slideIn 0.3s ease;
}

.error-content {
    display: flex;
    align-items: center;
    justify-content: space-between;
}

.error-close {
    background: none;
    border: none;
    color: white;
    font-size: 18px;
    cursor: pointer;
    margin-left: 10px;
    padding: 0;
    width: 20px;
    height: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    transition: background 0.3s ease;
}

.error-close:hover {
    background: rgba(255,255,255,0.2);
}

/* Highlight animation for events */
.highlight-event {
    animation: pulse 1s ease-in-out 3;
}

@keyframes pulse {
    0% {
        transform: scale(1);
        box-shadow: 0 0 0 0 rgba(102, 126, 234, 0.7);
    }
    50% {
        transform: scale(1.05);
        box-shadow: 0 0 20px 10px rgba(102, 126, 234, 0.3);
    }
    100% {
        transform: scale(1);
        box-shadow: 0 0 0 0 rgba(102, 126, 234, 0);
    }
}

/* Ensure events have data attributes for selection */
.fc-event {
    transition: all 0.3s ease;
} 
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\static\css\calendar.css ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\static\js\api.js:
const JSON_HEADERS = { 'Content-Type': 'application/json' };

function handle (res) {
  if (!res.ok) throw new Error(`${res.status} ${res.statusText}`);
  return res.json().then(j => j.data ?? j);
}

function request (method, url, body, token) {
  return fetch(url, {
    method,
    headers: {
      ...JSON_HEADERS,
      ...(token ? { 'X-CSRFToken': token } : {})
    },
    credentials: 'include',
    body: body ? JSON.stringify(body) : undefined
  }).then(handle);
}

export const api = {
  get  : (u)                => request('GET'   , u),
  post : (u, b, t)          => request('POST'  , u, b, t),
  patch: (u, b, t)          => request('PATCH' , u, b, t),
  del  : (u,  t)            => request('DELETE', u, null, t)
}; 
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\static\js\api.js ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\static\js\core.js:
/* global FullCalendar */

import { api } from './api.js';
import { ui }  from './ui.js';

document.addEventListener('DOMContentLoaded', () => {
  const calendarEl = document.getElementById('calendar');
  if (!calendarEl) return;

  // ------------------------------------------------------------------  
  // Runtime context
  // ------------------------------------------------------------------  
  const userId = document.querySelector('meta[name="user-id"]')?.content ?? 'default_user';
  const csrftoken = document.cookie
    .split('; ')
    .find(c => c.startsWith('csrftoken='))?.split('=')[1] ?? '';

  // ------------------------------------------------------------------  
  // FullCalendar instance
  // ------------------------------------------------------------------  
  const calendar = new FullCalendar.Calendar(calendarEl, {
    initialView: 'dayGridMonth',
    height: 'auto',
    dayMaxEvents: true,
    timeZone: 'local',
    headerToolbar: {
      left: 'prev,next today',
      center: 'title',
      right: 'dayGridMonth,timeGridWeek,timeGridDay'
    },

    dateClick (info) {
      // Format the clicked date as 'YYYY-MM-DDT14:00' for 2pm
      const date = new Date(info.dateStr);
      date.setHours(14, 0, 0, 0); // 2:00 PM
      // Format to 'YYYY-MM-DDTHH:MM' (datetime-local input expects this)
      const pad = n => n.toString().padStart(2, '0');
      const formatted = `${date.getFullYear()}-${pad(date.getMonth()+1)}-${pad(date.getDate())}T${pad(date.getHours())}:${pad(date.getMinutes())}`;
      ui.openEventModal({ start_time: formatted });
    },

    eventClick (info) {
      ui.openEventModal(info.event.extendedProps);
    }
  });

  // Expose for debugging
  window.calendar = calendar;
  calendar.render();
  
  // Load events after render
  loadEvents(calendar, userId);

  // ------------------------------------------------------------------  
  // Global listeners
  // ------------------------------------------------------------------  
  document.getElementById('add-event')
    ?.addEventListener('click', () => ui.openEventModal());

  ui.on('event:saved', payload => {
    payload.user_id = userId;
    // Calculate end_time from start_time and duration_minutes
    const start = new Date(payload.start_time);
    const duration = Number(payload.duration_minutes) || 60;
    const end = new Date(start.getTime() + duration * 60000);
    const pad = n => n.toString().padStart(2, '0');
    payload.end_time = `${end.getFullYear()}-${pad(end.getMonth()+1)}-${pad(end.getDate())}T${pad(end.getHours())}:${pad(end.getMinutes())}`;
    const req = payload.event_id
      ? api.patch(`/calendar/events/${payload.event_id}`, payload, csrftoken)
      : api.post('/calendar/events', payload, csrftoken);

    req.then(() => {
      // Add the new event directly to the calendar
      if (!payload.event_id) {
        // This is a new event, add it directly
        calendar.addEvent({
          id: payload.event_id,
          title: payload.title,
          start: payload.start_time,
          end: payload.end_time,
          allDay: false
        });
      } else {
        // This is an update, refresh all events
        calendar.refetchEvents();
      }
    })
    .catch(ui.toastError);
  });

  ui.on('event:deleted', eventId => {
    api.del(`/calendar/events/${eventId}`, csrftoken)
       .then(() => calendar.refetchEvents())
       .catch(ui.toastError);
  });
});

async function loadEvents(calendar, userId) {
  try {
    const uid = userId || 'default_user';

    const res = await fetch(`/calendar/events?user_id=${encodeURIComponent(uid)}`);
    if (!res.ok) {
      console.error('Fetch failed', res.status);
      return;
    }

    const raw = await res.json();          // API returns an array
    const mapped = raw.map(ev => ({
      id:    ev.event_id || ev.id,
      title: ev.title,
      start: ev.start_time,                // ISO 8601 string
      end:   ev.end_time,
      allDay: false
    }));

    calendar.addEventSource(mapped);
    console.log(`Loaded ${mapped.length} events`);
  } catch (err) {
    console.error(err);
  }
} 
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\static\js\core.js ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\static\js\mermaid.js:
/* global mermaid */

(function initMermaidObserver () {
  // Render any <code class="language-mermaid"> blocks that appear later
  const render = codeEl => {
    const container = document.createElement('div');
    container.className = 'mermaid';
    container.textContent = codeEl.textContent;
    codeEl.replaceWith(container);
    mermaid.init(undefined, container);

    // Click-through: each node id becomes clickable
    container.addEventListener('click', e => {
      if (e.target.tagName !== 'text') return;
      const id = e.target.textContent.trim();
      // Expect node text to be the event_id
      if (id.startsWith('EV')) {
        window.calendar?.selectEvent?.(id); // FullCalendar extension point
      }
    });
  };

  const observer = new MutationObserver(mutations => {
    mutations.forEach(m => {
      m.addedNodes.forEach(node => {
        if (node.nodeType === 1 && node.matches('code.language-mermaid')) {
          render(node);
        }
      });
    });
  });

  observer.observe(document.body, { childList: true, subtree: true });
})(); 
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\static\js\mermaid.js ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\static\js\ui.js:
/* Very small pub-sub modal helper */

const listeners = {};

function emit (evt, payload) {
  (listeners[evt] || []).forEach(fn => fn(payload));
}

export const ui = {
  on (evt, fn) {
    listeners[evt] = listeners[evt] || [];
    listeners[evt].push(fn);
  },

  toastError (err) {
    console.error(err);
    alert(err.message || 'An error occurred');
  },

  /* -------------------------------------------------------------- */
  /* Modal handling                                                 */
  /* -------------------------------------------------------------- */
  openEventModal (defaults = {}) {
    const modal = document.getElementById('event-modal');
    const form  = modal.querySelector('form');

    // Reset
    form.reset();
    form.event_id.value      = defaults.event_id      ?? '';
    form.title.value         = defaults.title         ?? '';
    form.start_time.value    = defaults.start_time    ?? '';
    form.duration_minutes.value = defaults.duration_minutes ?? 60;

    modal.showModal();

    // Improved outside click: close only if click is on the backdrop
    function outside (e) {
      if (e.target === modal) close();
    }
    function close () {
      modal.removeEventListener('click', outside);
      modal.close();
    }
    modal.addEventListener('click', outside);

    // Submit
    form.onsubmit = e => {
      e.preventDefault();
      const payload = Object.fromEntries(new FormData(form));
      payload.duration_minutes = Number(payload.duration_minutes);
      emit('event:saved', payload);
      close();
    };

    // Delete (visible only in edit mode)
    const delBtn = modal.querySelector('.delete');
    delBtn.style.display = defaults.event_id ? 'inline-block' : 'none';
    delBtn.onclick = () => {
      emit('event:deleted', defaults.event_id);
      close();
    };
  }
}; 
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\static\js\ui.js ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\tasks\daily.py:
"""
Daily reminder generator.

Creates same-day reminders for time-sensitive events
(e.g. send an email two hours before a scheduled meeting).
"""

from __future__ import annotations

import datetime as _dt
import logging
from typing import Dict, List

from ..services.calendar_client import CalendarClient

log = logging.getLogger("pitext_calendar.tasks.daily")

client = CalendarClient()


def create_daily_reminders() -> None:
    """
    Scan today's events and add reminder entries where appropriate.
    """
    today = _dt.date.today()
    events = client.list_events(user_id=None)  # all users
    targets = [ev for ev in events if _is_today(ev, today)]

    for ev in targets:
        _maybe_create_reminder(ev)

    log.info("Daily reminder job processed %d events", len(targets))


# ---------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------
def _is_today(event: Dict, today: _dt.date) -> bool:
    try:
        start = _dt.datetime.fromisoformat(event["start_time"])
    except Exception:
        return False
    return start.date() == today


def _maybe_create_reminder(event: Dict) -> None:
    # Only create if no existing reminder exists
    reminder_title = f"Reminder: {event['title']}"
    existing = [
        e for e in client.list_events(event["user_id"])
        if e.get("title") == reminder_title
    ]
    if existing:
        return

    reminder_payload = {
        "title": reminder_title,
        "start_time": (
            _dt.datetime.fromisoformat(event["start_time"]) - _dt.timedelta(hours=2)
        ).isoformat(),
        "duration_minutes": 15,
        "user_id": event["user_id"],
        "type": "reminder",
        "metadata": {"source_event": event.get("event_id", event.get("id", "unknown"))},
    }
    client.create_event(reminder_payload) 
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\tasks\daily.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\tasks\scheduler.py:
"""
Thin wrapper around the `schedule` library.

Runs tasks in a background thread; meant to be called
once during application start-up.

No web-framework or OS-specific code lives here.
"""

from __future__ import annotations

import logging
import threading
import time
from typing import Callable

import schedule

from .daily import create_daily_reminders
from .weekly import create_weekly_events

log = logging.getLogger("pitext_calendar.scheduler")


def _run_forever() -> None:
    """Blocking loop executed inside a daemon thread."""
    while True:
        schedule.run_pending()
        time.sleep(1)  # 1-second granularity is fine for calendar jobs


def _register_tasks() -> None:
    """Attach jobs to the global scheduler object."""
    schedule.every().day.at("00:05").do(create_daily_reminders)
    schedule.every().monday.at("00:10").do(create_weekly_events)
    log.info("Scheduled daily + weekly background jobs")


def start_scheduler(*, start_thread: bool = True) -> None:
    """
    Initialise the scheduler.
    If `start_thread` is False, the caller can run `_run_forever()` manually.
    """
    _register_tasks()
    if start_thread:
        thread = threading.Thread(target=_run_forever, name="scheduler", daemon=True)
        thread.start()
 
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\tasks\scheduler.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\tasks\weekly.py:
"""
Weekly maintenance job.

* Auto-creates routine events for the coming week.
* Delegates persistence to CalendarClient so no DB code appears here.
"""

from __future__ import annotations

import datetime as _dt
import logging
from typing import Dict, List

from ..services.calendar_client import CalendarClient

log = logging.getLogger("pitext_calendar.tasks.weekly")

client = CalendarClient()


# ---------------------------------------------------------------------
# Public entry-point (called by scheduler)
# ---------------------------------------------------------------------
def create_weekly_events() -> None:
    """
    Generate standard weekly events for every active user.
    Safe to call multiple times; CalendarClient handles idempotency.
    """
    users: List[str] = _fetch_active_user_ids()
    for uid in users:
        _safe_create(uid)
    log.info("Weekly events job completed for %d users", len(users))


# ---------------------------------------------------------------------
# Helpers (internal)
# ---------------------------------------------------------------------
def _fetch_active_user_ids() -> List[str]:
    # Replace with actual persistence (e.g. SQL SELECT)
    return ["user_demo"]


def _safe_create(user_id: str) -> None:
    base_date = _dt.date.today() + _dt.timedelta(days=1)  # start tomorrow
    template: Dict = {
        "duration_minutes": 30,
        "type": "maintenance",
        "user_id": user_id,
    }

    for i in range(7):  # next 7 days
        payload = template | {
            "title": "Daily reflection",
            "start_time": _combine(base_date + _dt.timedelta(days=i), hour=22).isoformat(),
        }
        try:
            client.create_event(payload)
        except Exception as exc:
            log.warning("Skipping duplicate or invalid event: %s", exc)


def _combine(date: _dt.date, *, hour: int) -> _dt.datetime:
    return _dt.datetime.combine(date, _dt.time(hour=hour)) 
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\tasks\weekly.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\tasks\__init__.py:
# tasks/__init__.py
"""
Task package public interface.

Typical usage
-------------
from pitext_calendar.tasks import start_scheduler
start_scheduler()
"""

from .scheduler import start_scheduler              # scheduler entry-point
from .weekly import create_weekly_events            # convenience re-exports
from .daily import create_daily_reminders

__all__ = [
    "start_scheduler",
    "create_weekly_events",
    "create_daily_reminders",
]

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\tasks\__init__.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\templates\calendar.html:
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>PiText - Calendar</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="user-id" content="{{ request.args.get('user_id', 'default_user') }}" />
  <link rel="icon" type="image/x-icon" href="{{ url_for('calendar_api.events.favicon') }}" />

  <!-- CSS Files -->
  <link rel="stylesheet" href="{{ url_for('calendar_api.static', filename='css/calendar.css') }}" />
</head>
<body>
  <div class="lightbulb-bg"></div>
  <div class="container">
    <header>
      <h1>📅 Calendar</h1>
    </header>

    <main>
      <!-- Import Google Calendar Button -->
      <div style="display: flex; justify-content: flex-end; align-items: center; margin-bottom: 10px;">
        <button id="import-google-calendar"><span id="google-calendar-status"></span> <span id="google-calendar-btn-text">Import Google Calendar</span></button>
      </div>
      <!-- Calendar Container -->
      <div id="calendar"></div>
    </main>
  </div>

  <!-- Event Modal -->
  <dialog id="event-modal">
    <form>
      <input type="hidden" name="event_id" />
      <div class="form-group">
        <label for="title">Title</label>
        <input type="text" name="title" required />
      </div>
      <div class="form-group">
        <label for="start_time">Start Time</label>
        <input type="datetime-local" name="start_time" required />
      </div>
      <div class="form-group">
        <label for="duration_minutes">Duration (minutes)</label>
        <input type="number" name="duration_minutes" value="60" min="15" step="15" />
      </div>
      <div class="form-actions">
        <button type="submit">Save</button>
        <button type="button" class="delete">Delete</button>
        <button type="button" onclick="this.closest('dialog').close()">Cancel</button>
      </div>
    </form>
  </dialog>

  <!-- FullCalendar Library -->
  <script src="https://cdn.jsdelivr.net/npm/fullcalendar@6.1.10/index.global.min.js"></script>

  <!-- Calendar Integration - Modular JavaScript -->
  <script type="module" src="{{ url_for('calendar_api.static', filename='js/core.js') }}"></script>
  <script src="{{ url_for('calendar_api.static', filename='js/mermaid.js') }}"></script>

  <!-- Pitext Dark Theme (load after default CSS) -->
  <link rel="stylesheet" href="{{ url_for('calendar_api.static', filename='css/calendar-dark-theme.css') }}" />

  <!-- Test Functions -->
  <script>
    document.getElementById('import-google-calendar').onclick = function() {
      // Get the current user_id from localStorage
      const userId = localStorage.getItem('pitext_user_id');
      
      if (!userId) {
          alert('Please refresh the page to initialize user session');
          return;
      }
      
      // Store it in session via a quick API call
      fetch('/calendar/set-session-user', {
          method: 'POST',
          headers: {
              'Content-Type': 'application/json'
          },
          body: JSON.stringify({ user_id: userId })
      }).then(response => {
          if (response.ok) {
              window.location.href = '/calendar/oauth/google/start';
          } else {
              alert('Failed to initialize session. Please try again.');
          }
      }).catch(error => {
          console.error('Error setting session:', error);
          alert('Failed to initialize session. Please try again.');
      });
    };

    // Google Calendar Import Success UI
    function getQueryParam(name) {
      const url = new URL(window.location.href);
      return url.searchParams.get(name);
    }
    function showGoogleCalendarConnected() {
      const btn = document.getElementById('import-google-calendar');
      const status = document.getElementById('google-calendar-status');
      const text = document.getElementById('google-calendar-btn-text');
      status.textContent = '✓';
      status.style.color = 'green';
      status.style.fontWeight = 'bold';
      status.style.marginRight = '4px';
      text.textContent = 'Google Calendar Connected';
      btn.disabled = true;
      // Show notification
      const notif = document.createElement('div');
      notif.textContent = 'Google Calendar imported successfully!';
      notif.style.background = '#38a169';
      notif.style.color = 'white';
      notif.style.padding = '10px 20px';
      notif.style.position = 'fixed';
      notif.style.top = '20px';
      notif.style.right = '20px';
      notif.style.borderRadius = '6px';
      notif.style.zIndex = 1000;
      notif.style.boxShadow = '0 2px 8px rgba(0,0,0,0.15)';
      document.body.appendChild(notif);
      setTimeout(() => notif.remove(), 3500);
      // Refresh calendar events if available
      if (window.piTextCalendar && window.piTextCalendar.refresh) {
        window.piTextCalendar.refresh();
      }
    }
    window.addEventListener('DOMContentLoaded', function() {
      if (getQueryParam('google_import') === 'success') {
        showGoogleCalendarConnected();
      }
    });

    // Listen for calendar ready event
    window.addEventListener('calendarReady', function(event) {
      console.log('Calendar is ready:', event.detail);
    });
  </script>

  <style>
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
    }

    header {
      text-align: center;
      margin-bottom: 30px;
    }

    header h1 {
      color: #667eea;
      margin-bottom: 10px;
    }

    /* Modal styles */
    #event-modal {
      border: none;
      border-radius: 8px;
      padding: 20px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.2);
    }

    #event-modal::backdrop {
      background: rgba(0,0,0,0.5);
    }

    .form-group {
      margin-bottom: 15px;
    }

    .form-group label {
      display: block;
      margin-bottom: 5px;
      font-weight: 500;
    }

    .form-group input {
      width: 100%;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
    }

    .form-actions {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
      margin-top: 20px;
    }

    .form-actions button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }

    .form-actions button[type="submit"] {
      background: #667eea;
      color: white;
    }

    .form-actions .delete {
      background: #dc3545;
      color: white;
    }

    .form-actions button[type="button"] {
      background: #6c757d;
      color: white;
    }
  </style>
</body>
</html> 
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\templates\calendar.html ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\utils\datetime.py:
"""
Datetime helpers with no external deps.

All functions work with stdlib `datetime` and `zoneinfo`.
"""

from __future__ import annotations

import datetime as _dt
from typing import Final, Tuple
from zoneinfo import ZoneInfo

_EASTERN: Final[ZoneInfo] = ZoneInfo("America/New_York")


# ---------------------------------------------------------------------
# Parsing helpers
# ---------------------------------------------------------------------
def parse_iso(value: str, *, assume_tz: str | None = None) -> _dt.datetime:
    """
    Robust ISO-8601 parser.
    * If value lacks timezone, attach `assume_tz` (default local).
    * Return aware datetime.
    """
    dt = _dt.datetime.fromisoformat(value)
    if dt.tzinfo is None:
        tz = ZoneInfo(assume_tz) if assume_tz else _dt.datetime.now().astimezone().tzinfo
        dt = dt.replace(tzinfo=tz)
    return dt


def to_eastern(dt: _dt.datetime) -> _dt.datetime:
    """Convert aware datetime to US Eastern."""
    return dt.astimezone(_EASTERN)


# ---------------------------------------------------------------------
# Convenience shortcuts
# ---------------------------------------------------------------------
def now_utc() -> _dt.datetime:
    return _dt.datetime.now(tz=_dt.timezone.utc)


def today_range(tz: str = "UTC") -> Tuple[_dt.datetime, _dt.datetime]:
    """
    Return (start, end) datetimes for today in given timezone.
    """
    zone = ZoneInfo(tz)
    midnight = _dt.datetime.now(zone).replace(hour=0, minute=0, second=0, microsecond=0)
    return (midnight, midnight + _dt.timedelta(days=1))


# ---------------------------------------------------------------------
# Backward compatibility
# ---------------------------------------------------------------------
def parse_datetime(date_str: str):
    """Parse datetime string in various formats including ISO format."""
    if not date_str:
        raise ValueError("Date string cannot be empty")
    
    # Try ISO format first (what JavaScript typically sends)
    try:
        return _dt.datetime.fromisoformat(date_str.replace('Z', '+00:00'))
    except ValueError:
        pass
    
    # Try common datetime formats
    formats = [
        "%Y-%m-%dT%H:%M:%S.%fZ",  # ISO with milliseconds and Z
        "%Y-%m-%dT%H:%M:%S.%f",   # ISO with milliseconds
        "%Y-%m-%dT%H:%M:%SZ",     # ISO with Z
        "%Y-%m-%dT%H:%M:%S",      # ISO without timezone
        "%Y-%m-%d %H:%M:%S",      # Space separated
        "%Y-%m-%d",               # Date only
    ]
    
    for fmt in formats:
        try:
            return _dt.datetime.strptime(date_str, fmt)
        except ValueError:
            continue
    
    # If all formats fail, try to clean up the string and parse
    # Remove timezone info and try again
    import re
    cleaned_str = re.sub(r'[+-]\d{2}:?\d{2}$', '', date_str)
    cleaned_str = cleaned_str.replace('Z', '')
    
    try:
        return _dt.datetime.fromisoformat(cleaned_str)
    except ValueError:
        pass
    
    raise ValueError(f"Unable to parse date string: {date_str}. Expected ISO format or standard datetime format.") 
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\utils\datetime.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\utils\logger.py:
"""
Unified logging helper.

`get_logger(__name__)` returns a logger that writes:
* human-readable lines to stdout
* daily-rotated files under ~/.pitext/logs/
"""

from __future__ import annotations

import logging
import os
from pathlib import Path
from typing import Final

from logging.handlers import TimedRotatingFileHandler

_LOG_DIR: Final[Path] = Path.home() / ".pitext" / "logs"
_LOG_DIR.mkdir(parents=True, exist_ok=True)

_FMT: Final[str] = "%(asctime)s | %(levelname)-8s | %(name)s | %(message)s"
_DATEFMT: Final[str] = "%Y-%m-%d %H:%M:%S"


def _file_handler(name: str) -> logging.Handler:
    file_path = _LOG_DIR / f"{name}.log"
    handler = TimedRotatingFileHandler(
        file_path, when="midnight", backupCount=14, encoding="utf-8"
    )
    handler.setFormatter(logging.Formatter(_FMT, _DATEFMT))
    return handler


def _stdout_handler() -> logging.Handler:
    handler = logging.StreamHandler()
    handler.setFormatter(logging.Formatter(_FMT, _DATEFMT))
    return handler


def get_logger(name: str, level: int = logging.INFO) -> logging.Logger:
    logger = logging.getLogger(name)
    if logger.handlers:  # already configured
        return logger

    logger.setLevel(level)
    logger.addHandler(_stdout_handler())
    logger.addHandler(_file_handler(name.replace(".", "_")))
    logger.propagate = False
    return logger 
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\utils\logger.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\utils\validators.py:
"""
Lightweight validation helpers.

These are pure Python utilities—no Pydantic, Marshmallow or Flask.
"""

from __future__ import annotations

import re
from datetime import datetime
from typing import Iterable, Mapping


_EMAIL_RE = re.compile(r"^[^\s@]+@[^\s@]+\.[^\s@]+$")


def is_email(value: str) -> bool:
    return bool(_EMAIL_RE.fullmatch(value))


def require_keys(mapping: Mapping, keys: Iterable[str]) -> None:
    """
    Raise ValueError if any key is missing.
    Useful for validating incoming dict payloads.
    """
    missing = [k for k in keys if k not in mapping]
    if missing:
        raise ValueError(f"Missing keys: {', '.join(missing)}")


def require_iso_datetime(value: str) -> None:
    try:
        datetime.fromisoformat(value)
    except Exception as exc:
        raise ValueError("Not a valid ISO-8601 datetime") from exc


def validate_event_data(event_data: dict):
    """Validate calendar event data."""
    required_fields = ['title', 'start_time', 'end_time']
    missing_fields = [field for field in required_fields if field not in event_data]

    if missing_fields:
        raise ValueError(f"Missing required event fields: {', '.join(missing_fields)}")

    start_time = event_data.get('start_time')
    end_time = event_data.get('end_time')

    # Check if start_time and end_time are not None before comparison
    if start_time is None or end_time is None:
        raise ValueError("Both 'start_time' and 'end_time' must be provided and not None.")

    if start_time >= end_time:
        raise ValueError("Event 'end_time' must be after 'start_time'.")

    return True
# Validation Functions 
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\utils\validators.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\utils\__init__.py:
# utils/__init__.py
from .datetime import parse_datetime, parse_iso, to_eastern, now_utc, today_range
from .validators import validate_event_data, is_email, require_keys, require_iso_datetime
from .logger import get_logger

__all__ = [
    "parse_datetime",
    "parse_iso", 
    "to_eastern",
    "now_utc",
    "today_range",
    "validate_event_data",
    "is_email",
    "require_keys", 
    "require_iso_datetime",
    "get_logger"
]
# Utils Module 
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\calendar_integration\utils\__init__.py ---

